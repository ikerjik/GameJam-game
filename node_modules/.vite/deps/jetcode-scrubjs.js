// node_modules/jetcode-scrubjs/dist/scrub.mjs
var rt = class {
  constructor(t, e, i = 0) {
    this.connectActions = [g.JOINED, g.RECEIVE_DATA, g.MEMBER_JOINED, g.MEMBER_LEFT, g.GAME_STARTED, g.GAME_STOPPED, g.ERROR];
    this.socket = t, this.lobbyId = i, this.memberId = null, this.connects = {}, this._listenSocket();
  }
  _listenSocket() {
    this.socket.onmessage = (t) => {
      let [e, i, s] = this._parse(t.data);
      e === g.RECEIVE_DATA ? this.emit(g.RECEIVE_DATA, [s, i, (i == null ? void 0 : i.MemberId) === this.memberId]) : e === g.MEMBER_JOINED ? this.emit(g.MEMBER_JOINED, [i, (i == null ? void 0 : i.MemberId) === this.memberId]) : e === g.MEMBER_LEFT ? this.emit(g.MEMBER_LEFT, [i, (i == null ? void 0 : i.MemberId) === this.memberId]) : this.connects[e] && this.emit(e, [i]);
    };
  }
  emit(t, e) {
    this.connects[t] && this.connects[t].forEach((i) => {
      i(...e);
    });
  }
  connect(t, e) {
    if (!this.connectActions.includes(t)) throw new Error("This actions is not defined.");
    return this.connects[t] || (this.connects[t] = []), this.connects[t].push(e), e;
  }
  disconnect(t, e) {
    if (!this.connectActions.includes(t)) throw new Error("This action is not defined.");
    this.connects[t] && (this.connects[t] = this.connects[t].filter((i) => i !== e));
  }
  sendData(t, e = {}) {
    if (!this.lobbyId) throw new Error("You are not in the lobby!");
    let i = `${g.SEND_DATA}
`;
    for (let [s, n] of Object.entries(e)) i += s + "=" + n + `
`;
    i += `SendTime=${Date.now()}
`, i += `
` + t, this.socket.send(i);
  }
  joinLobby(t, e, i = {}) {
    return new Promise((s, n) => {
      e || (e = 0);
      let r = `${g.JOIN_LOBBY}
`;
      r += `GameToken=${t}
`, r += `LobbyId=${e}
`;
      for (let [o, a] of Object.entries(i)) r += `${o}=${a}
`;
      this.socket.send(r), this.connect(g.JOINED, (o) => {
        if (o.LobbyId && o.MemberId && o.CurrentTime) {
          this.lobbyId = o.LobbyId, this.memberId = o.MemberId;
          let a = Date.now();
          this.deltaTime = a - Number(o.CurrentTime), s(this.lobbyId);
        } else n(new Error("Couldn't join the lobby"));
      });
    });
  }
  leaveLobby() {
    if (!this.lobbyId) return;
    let t = `${g.LEAVE_LOBBY}
LobbyId=${this.lobbyId}
`;
    this.socket.send(t), this.lobbyId = null;
  }
  _parse(t) {
    let e = t.split(`
`), i = e[0], s = "", n = [], r = "parameters";
    for (let o = 1; o < e.length; o++) {
      let a = e[o];
      if (a === "" && r === "parameters") r = "value";
      else if (r === "parameters") {
        let l = a.split("="), h = l[0];
        n[h] = l.length > 1 ? l[1] : null;
      } else r === "value" && (s = s + a + `
`);
    }
    return s && (s = s.slice(0, -1)), [i, n, s];
  }
};
var g = class {
  constructor(t = "ws://localhost:17500") {
    this.socketUrl = t, this.socket = null, this.defaultParameters = { LobbyAutoCreate: true, MaxMembers: 2, MinMembers: 2, StartGameWithMembers: 2 };
  }
  connect(t, e = null, i = {}) {
    let s = { ...this.defaultParameters, ...i };
    return new Promise((n, r) => {
      this.socket = new WebSocket(this.socketUrl), this.socket.onopen = () => {
        let o = new rt(this.socket, t, e);
        o.joinLobby(t, e, s).then(() => {
          n(o);
        }).catch(r);
      }, this.socket.onerror = (o) => {
        r(o);
      };
    });
  }
};
g.JOIN_LOBBY = "JOIN_LOBBY", g.LEAVE_LOBBY = "LEAVE_LOBBY", g.SEND_DATA = "SEND_DATA", g.JOINED = "JOINED", g.RECEIVE_DATA = "RECEIVE_DATA", g.MEMBER_JOINED = "MEMBER_JOINED", g.MEMBER_LEFT = "MEMBER_LEFT", g.GAME_STARTED = "GAME_STARTED", g.GAME_STOPPED = "GAME_STOPPED", g.ERROR = "ERROR";
var Ct = [];
var it = class u {
  constructor() {
    this._bvh_parent = null;
    this._bvh_branch = true;
    this._bvh_left = null;
    this._bvh_right = null;
    this._bvh_sort = 0;
    this._bvh_min_x = 0;
    this._bvh_min_y = 0;
    this._bvh_max_x = 0;
    this._bvh_max_y = 0;
  }
  static getBranch() {
    return Ct.length ? Ct.pop() : new u();
  }
  static releaseBranch(t) {
    Ct.push(t);
  }
  static sortBranches(t, e) {
    return t.sort > e.sort ? -1 : 1;
  }
};
var V = class V2 {
  constructor() {
    this._hierarchy = null;
    this._bodies = [];
    this._dirty_branches = [];
  }
  insert(t, e = false) {
    if (!e) {
      let p = t._bvh;
      if (p && p !== this) throw new Error("Body belongs to another collision system");
      t._bvh = this, this._bodies.push(t);
    }
    let i = t._polygon, s = t.x, n = t.y;
    i && (t._dirty_coords || t.x !== t._x || t.y !== t._y || t.angle !== t._angle || t.scale_x !== t._scale_x || t.scale_y !== t._scale_y) && t._calculateCoords();
    let r = t._bvh_padding, o = i ? 0 : t.radius * t.scale, a = (i ? t._min_x : s - o) - r, l = (i ? t._min_y : n - o) - r, h = (i ? t._max_x : s + o) + r, d = (i ? t._max_y : n + o) + r;
    t._bvh_min_x = a, t._bvh_min_y = l, t._bvh_max_x = h, t._bvh_max_y = d;
    let c = this._hierarchy, _ = 0;
    if (!c) this._hierarchy = t;
    else {
      let p = 0;
      for (; p++ < V2.MAX_DEPTH; ) if (c._bvh_branch) {
        let m = c._bvh_left, f = m._bvh_min_y, b = m._bvh_max_x, v = m._bvh_max_y, C = a < m._bvh_min_x ? a : m._bvh_min_x, S = l < f ? l : f, x = h > b ? h : b, N = d > v ? d : v, F = (b - m._bvh_min_x) * (v - f), tt = (x - C) * (N - S) - F, I = c._bvh_right, A = I._bvh_min_x, z = I._bvh_min_y, j = I._bvh_max_x, T = I._bvh_max_y, R = a < A ? a : A, O = l < z ? l : z, U = h > j ? h : j, $ = d > T ? d : T, et = (j - A) * (T - z), nt = (U - R) * ($ - O) - et;
        c._bvh_sort = _++, c._bvh_min_x = C < R ? C : R, c._bvh_min_y = S < O ? S : O, c._bvh_max_x = x > U ? x : U, c._bvh_max_y = N > $ ? N : $, c = tt <= nt ? m : I;
      } else {
        let m = c._bvh_parent, f = c._bvh_min_x, b = c._bvh_min_y, v = c._bvh_max_x, C = c._bvh_max_y, S = c._bvh_parent = t._bvh_parent = it.getBranch();
        S._bvh_parent = m, S._bvh_left = c, S._bvh_right = t, S._bvh_sort = _++, S._bvh_min_x = a < f ? a : f, S._bvh_min_y = l < b ? l : b, S._bvh_max_x = h > v ? h : v, S._bvh_max_y = d > C ? d : C, m ? m._bvh_left === c ? m._bvh_left = S : m._bvh_right = S : this._hierarchy = S;
        break;
      }
    }
  }
  remove(t, e = false) {
    if (!e) {
      let o = t._bvh;
      if (o && o !== this) throw new Error("Body belongs to another collision system");
      t._bvh = null, this._bodies.splice(this._bodies.indexOf(t), 1);
    }
    if (this._hierarchy === t) {
      this._hierarchy = null;
      return;
    }
    let i = t._bvh_parent;
    if (!i) {
      console.error("The parent is not defined in the collision system.");
      return;
    }
    let s = i._bvh_parent, n = i._bvh_left, r = n === t ? i._bvh_right : n;
    if (r._bvh_parent = s, r._bvh_branch && (r._bvh_sort = i._bvh_sort), s) {
      s._bvh_left === i ? s._bvh_left = r : s._bvh_right = r;
      let o = s, a = 0;
      for (; o && a++ < V2.MAX_DEPTH; ) {
        let l = o._bvh_left, h = l._bvh_min_x, d = l._bvh_min_y, c = l._bvh_max_x, _ = l._bvh_max_y, p = o._bvh_right, m = p._bvh_min_x, f = p._bvh_min_y, b = p._bvh_max_x, v = p._bvh_max_y;
        o._bvh_min_x = h < m ? h : m, o._bvh_min_y = d < f ? d : f, o._bvh_max_x = c > b ? c : b, o._bvh_max_y = _ > v ? _ : v, o = o._bvh_parent;
      }
    } else this._hierarchy = r;
    it.releaseBranch(i);
  }
  update() {
    let t = this._bodies, e = t.length;
    for (let i = 0; i < e; ++i) {
      let s = t[i], n = false;
      if (!n && s.padding !== s._bvh_padding && (s._bvh_padding = s.padding, n = true), !n) {
        let r = s._polygon;
        r && (s._dirty_coords || s.x !== s._x || s.y !== s._y || s.angle !== s._angle || s.scale_x !== s._scale_x || s.scale_y !== s._scale_y) && s._calculateCoords();
        let o = s.x, a = s.y, l = r ? 0 : s.radius * s.scale, h = r ? s._min_x : o - l, d = r ? s._min_y : a - l, c = r ? s._max_x : o + l, _ = r ? s._max_y : a + l;
        n = h < s._bvh_min_x || d < s._bvh_min_y || c > s._bvh_max_x || _ > s._bvh_max_y;
      }
      n && (this.remove(s, true), this.insert(s, true));
    }
  }
  potentials(t) {
    let e = [], i = t._bvh_min_x, s = t._bvh_min_y, n = t._bvh_max_x, r = t._bvh_max_y, o = this._hierarchy, a = true;
    if (!o || !o._bvh_branch) return e;
    let l = 0;
    for (; o && l++ < V2.MAX_DEPTH; ) {
      if (a) {
        a = false;
        let c = o._bvh_branch ? o._bvh_left : null;
        for (; c && c._bvh_max_x >= i && c._bvh_max_y >= s && c._bvh_min_x <= n && c._bvh_min_y <= r; ) o = c, c = o._bvh_branch ? o._bvh_left : null;
      }
      let h = o._bvh_branch, d = h ? o._bvh_right : null;
      if (d && d._bvh_max_x > i && d._bvh_max_y > s && d._bvh_min_x < n && d._bvh_min_y < r) o = d, a = true;
      else {
        !h && o !== t && e.push(o);
        let c = o._bvh_parent;
        if (c) {
          for (; c && c._bvh_right === o; ) o = c, c = o._bvh_parent;
          o = c;
        } else break;
      }
    }
    return e;
  }
  draw(t) {
    let e = this._bodies, i = e.length;
    for (let s = 0; s < i; ++s) e[s].draw(t);
  }
  drawBVH(t) {
    let e = this._hierarchy, i = true;
    for (; e; ) {
      if (i) {
        i = false;
        let h = e._bvh_branch ? e._bvh_left : null;
        for (; h; ) e = h, h = e._bvh_branch ? e._bvh_left : null;
      }
      let s = e._bvh_branch, n = e._bvh_min_x, r = e._bvh_min_y, o = e._bvh_max_x, a = e._bvh_max_y, l = s ? e._bvh_right : null;
      if (t.moveTo(n, r), t.lineTo(o, r), t.lineTo(o, a), t.lineTo(n, a), t.lineTo(n, r), l) e = l, i = true;
      else {
        let h = e._bvh_parent;
        if (h) {
          for (; h && h._bvh_right === e; ) e = h, h = e._bvh_parent;
          e = h;
        } else break;
      }
    }
  }
};
V.MAX_DEPTH = 1e4;
var ot = V;
function at(u6, t, e = null, i = true) {
  let s = u6._polygon, n = t._polygon, r = false;
  return e && (e.a = u6, e.b = t, e.a_in_b = true, e.b_in_a = true, e.overlap = null, e.overlap_x = 0, e.overlap_y = 0, e.collidedSprite = null), s && (u6._dirty_coords || u6.x !== u6._x || u6.y !== u6._y || u6.angle !== u6._angle || u6.scale_x !== u6._scale_x || u6.scale_y !== u6._scale_y) && u6._calculateCoords(), n && (t._dirty_coords || t.x !== t._x || t.y !== t._y || t.angle !== t._angle || t.scale_x !== t._scale_x || t.scale_y !== t._scale_y) && t._calculateCoords(), (!i || Rt(u6, t)) && (s && u6._dirty_normals && u6._calculateNormals(), n && t._dirty_normals && t._calculateNormals(), r = s && n ? Mt(u6, t, e) : s ? xt(u6, t, e, false) : n ? xt(t, u6, e, true) : Dt(u6, t, e)), e && (e.collision = r), r;
}
function Rt(u6, t) {
  let e = u6._polygon, i = e ? 0 : u6.x, s = e ? 0 : u6.y, n = e ? 0 : u6.radius * u6.scale, r = e ? u6._min_x : i - n, o = e ? u6._min_y : s - n, a = e ? u6._max_x : i + n, l = e ? u6._max_y : s + n, h = t._polygon, d = h ? 0 : t.x, c = h ? 0 : t.y, _ = h ? 0 : t.radius * t.scale, p = h ? t._min_x : d - _, m = h ? t._min_y : c - _, f = h ? t._max_x : d + _, b = h ? t._max_y : c + _;
  return r < f && o < b && a > p && l > m;
}
function Mt(u6, t, e = null) {
  let i = u6._coords.length, s = t._coords.length;
  if (i === 2 && s === 2) {
    let l = u6._coords, h = t._coords;
    return e && (e.overlap = 0), l[0] === h[0] && l[1] === h[1];
  }
  let n = u6._coords, r = t._coords, o = u6._normals, a = t._normals;
  if (i > 2) {
    for (let l = 0, h = 1; l < i; l += 2, h += 2) if (wt(n, r, o[l], o[h], e)) return false;
  }
  if (s > 2) {
    for (let l = 0, h = 1; l < s; l += 2, h += 2) if (wt(n, r, a[l], a[h], e)) return false;
  }
  return true;
}
function xt(u6, t, e = null, i = false) {
  let s = u6._coords, n = u6._edges, r = u6._normals, o = t.x, a = t.y, l = t.radius * t.scale, h = l * 2, d = l * l, c = s.length, _ = true, p = true, m = null, f = 0, b = 0;
  if (c === 2) {
    let v = o - s[0], C = a - s[1], S = v * v + C * C;
    if (S > d) return false;
    if (e) {
      let x = Math.sqrt(S);
      m = l - x, f = v / x, b = C / x, p = false;
    }
  } else for (let v = 0, C = 1; v < c; v += 2, C += 2) {
    let S = o - s[v], x = a - s[C], N = n[v], F = n[C], J = S * N + x * F, tt = J < 0 ? -1 : J > N * N + F * F ? 1 : 0, I = false, A = 0, z = 0, j = 0;
    if (e && _ && S * S + x * x > d && (_ = false), tt) {
      let T = tt === -1, R = T ? v === 0 ? c - 2 : v - 2 : v === c - 2 ? 0 : v + 2, O = R + 1, U = o - s[R], $ = a - s[O], et = n[R], st = n[O], nt = U * et + $ * st;
      if ((nt < 0 ? -1 : nt > et * et + st * st ? 1 : 0) === -tt) {
        let yt = T ? S : U, vt = T ? x : $, Et = yt * yt + vt * vt;
        if (Et > d) return false;
        if (e) {
          let St = Math.sqrt(Et);
          I = true, A = l - St, z = yt / St, j = vt / St, p = false;
        }
      }
    } else {
      let T = r[v], R = r[C], O = S * T + x * R, U = O < 0 ? -O : O;
      if (O > 0 && U > l) return false;
      e && (I = true, A = l - O, z = T, j = R, (p && O >= 0 || A < h) && (p = false));
    }
    I && (m === null || m > A) && (m = A, f = z, b = j);
  }
  return e && (e.a_in_b = i ? p : _, e.b_in_a = i ? _ : p, e.overlap = m, e.overlap_x = i ? -f : f, e.overlap_y = i ? -b : b), true;
}
function Dt(u6, t, e = null) {
  let i = u6.radius * u6.scale, s = t.radius * t.scale, n = t.x - u6.x, r = t.y - u6.y, o = i + s, a = n * n + r * r;
  if (a > o * o) return false;
  if (e) {
    let l = Math.sqrt(a);
    e.a_in_b = i <= s && l <= s - i, e.b_in_a = s <= i && l <= i - s, e.overlap = o - l, e.overlap_x = n / l, e.overlap_y = r / l;
  }
  return true;
}
function wt(u6, t, e, i, s = null) {
  let n = u6.length, r = t.length;
  if (!n || !r) return true;
  let o = null, a = null, l = null, h = null;
  for (let d = 0, c = 1; d < n; d += 2, c += 2) {
    let _ = u6[d] * e + u6[c] * i;
    (o === null || o > _) && (o = _), (a === null || a < _) && (a = _);
  }
  for (let d = 0, c = 1; d < r; d += 2, c += 2) {
    let _ = t[d] * e + t[c] * i;
    (l === null || l > _) && (l = _), (h === null || h < _) && (h = _);
  }
  if (o > h || a < l) return true;
  if (s) {
    let d = 0;
    if (o < l) if (s.a_in_b = false, a < h) d = a - l, s.b_in_a = false;
    else {
      let p = a - l, m = h - o;
      d = p < m ? p : -m;
    }
    else if (s.b_in_a = false, a > h) d = o - h, s.a_in_b = false;
    else {
      let p = a - l, m = h - o;
      d = p < m ? p : -m;
    }
    let c = s.overlap, _ = d < 0 ? -d : d;
    if (c === null || c > _) {
      let p = d < 0 ? -1 : 1;
      s.overlap = _, s.overlap_x = e * p, s.overlap_y = i * p;
    }
  }
  return false;
}
var M = class {
  constructor() {
    this.collision = false;
    this.a = null;
    this.b = null;
    this.a_in_b = false;
    this.b_in_a = false;
    this.overlap = 0;
    this.overlap_x = 0;
    this.overlap_y = 0;
  }
};
var q = class {
  constructor(t = 0, e = 0, i = 5) {
    this._offset_x = 0;
    this._offset_y = 0;
    this._circle = false;
    this._polygon = false;
    this._point = false;
    this._bvh = null;
    this._bvh_parent = null;
    this._bvh_branch = false;
    this._bvh_min_x = 0;
    this._bvh_min_y = 0;
    this._bvh_max_x = 0;
    this._bvh_max_y = 0;
    this._parent_sprite = null;
    this._center_distance = 0;
    this._center_angle = 0;
    this.x = t, this.y = e, this.padding = i, this._bvh_padding = i;
  }
  collides(t, e = null, i = true) {
    return at(this, t, e, i);
  }
  potentials() {
    let t = this._bvh;
    if (t === null) throw new Error("Body does not belong to a collision system");
    return t.potentials(this);
  }
  remove() {
    let t = this._bvh;
    t && t.remove(this, false);
  }
  set parentSprite(t) {
    this._parent_sprite = t;
  }
  get parentSprite() {
    return this._parent_sprite;
  }
  set offset_x(t) {
    this._offset_x = -t, this.updateCenterParams();
  }
  get offset_x() {
    return -this._offset_x;
  }
  set offset_y(t) {
    this._offset_y = -t, this.updateCenterParams();
  }
  get offset_y() {
    return -this._offset_y;
  }
  get center_offset_x() {
    if (this._parent_sprite.rotateStyle === "leftRight" || this._parent_sprite.rotateStyle === "none") {
      let t = this._parent_sprite._direction > 180 && this._parent_sprite.rotateStyle === "leftRight" ? -1 : 1;
      return this._offset_x * t;
    }
    return this._center_distance * Math.cos(this._center_angle - this._parent_sprite.globalAngleRadians);
  }
  get center_offset_y() {
    return this._parent_sprite.rotateStyle === "leftRight" || this._parent_sprite.rotateStyle === "none" ? -this._offset_y : -this._center_distance * Math.sin(this._center_angle - this._parent_sprite.globalAngleRadians);
  }
  createResult() {
    return new M();
  }
  updateCenterParams() {
    this._center_distance = Math.hypot(this._offset_x, this._offset_y), this._center_angle = -Math.atan2(-this._offset_y, -this._offset_x);
  }
  static createResult() {
    return new M();
  }
};
var Y = class extends q {
  constructor(t = 0, e = 0, i = 0, s = 1, n = 5) {
    super(t, e, n), this.radius = i, this.scale = s;
  }
  draw(t) {
    let e = this.x, i = this.y, s = this.radius * this.scale;
    t.moveTo(e + s, i), t.arc(e, i, s, 0, Math.PI * 2);
  }
};
var w = class u2 extends q {
  constructor(e = 0, i = 0, s = [], n = 0, r = 1, o = 1, a = 5) {
    super(e, i, a);
    this._min_x = 0;
    this._min_y = 0;
    this._max_x = 0;
    this._max_y = 0;
    this._points = null;
    this._coords = null;
    this._edges = null;
    this._normals = null;
    this._dirty_coords = true;
    this._dirty_normals = true;
    this._origin_points = null;
    this.angle = n, this.scale_x = r, this.scale_y = o, this._polygon = true, this._x = e, this._y = i, this._angle = n, this._scale_x = r, this._scale_y = o, this._origin_points = s, u2.prototype.setPoints.call(this, s);
  }
  draw(e) {
    (this._dirty_coords || this.x !== this._x || this.y !== this._y || this.angle !== this._angle || this.scale_x !== this._scale_x || this.scale_y !== this._scale_y) && this._calculateCoords();
    let i = this._coords;
    if (i.length === 2) e.moveTo(i[0], i[1]), e.arc(i[0], i[1], 1, 0, Math.PI * 2);
    else {
      e.moveTo(i[0], i[1]);
      for (let s = 2; s < i.length; s += 2) e.lineTo(i[s], i[s + 1]);
      i.length > 4 && e.lineTo(i[0], i[1]);
    }
  }
  setPoints(e) {
    let i = e.length;
    this._points = new Float64Array(i * 2), this._coords = new Float64Array(i * 2), this._edges = new Float64Array(i * 2), this._normals = new Float64Array(i * 2);
    let s = this._points;
    for (let n = 0, r = 0, o = 1; n < i; ++n, r += 2, o += 2) {
      let a = e[n];
      s[r] = a[0], s[o] = a[1];
    }
    this._dirty_coords = true;
  }
  _calculateCoords() {
    let e = this.x, i = this.y, s = this.angle, n = this.scale_x, r = this.scale_y, o = this._points, a = this._coords, l = o.length, h, d, c, _;
    for (let p = 0, m = 1; p < l; p += 2, m += 2) {
      let f = o[p] * n, b = o[m] * r;
      if (s) {
        let v = Math.cos(s), C = Math.sin(s), S = f, x = b;
        f = S * v - x * C, b = S * C + x * v;
      }
      f += e, b += i, a[p] = f, a[m] = b, p === 0 ? (h = d = f, c = _ = b) : (f < h ? h = f : f > d && (d = f), b < c ? c = b : b > _ && (_ = b));
    }
    this._x = e, this._y = i, this._angle = s, this._scale_x = n, this._scale_y = r, this._min_x = h, this._min_y = c, this._max_x = d, this._max_y = _, this._dirty_coords = false, this._dirty_normals = true;
  }
  _calculateNormals() {
    let e = this._coords, i = this._edges, s = this._normals, n = e.length;
    for (let r = 0, o = 1; r < n; r += 2, o += 2) {
      let a = r + 2 < n ? r + 2 : 0, l = e[a] - e[r], h = e[a + 1] - e[o], d = l || h ? Math.sqrt(l * l + h * h) : 0;
      i[r] = l, i[o] = h, s[r] = d ? h / d : 0, s[o] = d ? -l / d : 0;
    }
    this._dirty_normals = false;
  }
  get points() {
    return this._origin_points;
  }
};
var L = class extends w {
  constructor(t = 0, e = 0, i = 5) {
    super(t, e, [[0, 0]], 0, 1, 1, i), this._point = true;
  }
};
L.prototype.setPoints = void 0;
var lt = class {
  constructor() {
    this._bvh = new ot();
  }
  createCircle(t = 0, e = 0, i = 0, s = 1, n = 0) {
    let r = new Y(t, e, i, s, n);
    return this._bvh.insert(r), r;
  }
  createPolygon(t = 0, e = 0, i = [[0, 0]], s = 0, n = 1, r = 1, o = 0) {
    let a = new w(t, e, i, s, n, r, o);
    return this._bvh.insert(a), a;
  }
  createPoint(t = 0, e = 0, i = 0) {
    let s = new L(t, e, i);
    return this._bvh.insert(s), s;
  }
  createResult() {
    return new M();
  }
  static createResult() {
    return new M();
  }
  insert(...t) {
    for (let e of t) this._bvh.insert(e, false);
    return this;
  }
  remove(...t) {
    for (let e of t) this._bvh.remove(e, false);
    return this;
  }
  update() {
    return this._bvh.update(), this;
  }
  draw(t) {
    return this._bvh.draw(t);
  }
  drawBVH(t) {
    return this._bvh.drawBVH(t);
  }
  potentials(t) {
    return this._bvh.potentials(t);
  }
  collides(t, e, i = null, s = true) {
    return at(t, e, i, s);
  }
};
var E = class E2 {
  static getMessage(t, e, i = null) {
    if (!E2.messages[t]) throw new Error("Message is not defined.");
    if (!E2.messages[t][e]) throw new Error("Message for this locale is not defined.");
    let s = E2.messages[t][e];
    return i && (s = E2.replaceVariables(s, i)), s;
  }
  static replaceVariables(t, e) {
    return t.replace(/\${([^}]+)}/g, (i, s) => e[s] !== void 0 ? e[s] : "");
  }
};
E.SCRIPT_ERROR = "script_error", E.MISTAKE_METHOD = "mistake_method", E.MISTAKE_METHOD_WITH_CLOSEST = "mistake_method_with_closest", E.NEED_STAGE_BEFORE_RUN_GAME = "need_stage_before_run_game", E.NEED_CREATE_STAGE_BEFORE_SPRITE = "need_create_stage_before_sprite", E.COSTUME_NOT_LOADED = "costume_not_loaded", E.BACKGROUND_NOT_LOADED = "background_not_loaded", E.CLONED_NOT_READY = "cloned_not_ready", E.SOUND_INDEX_NOT_FOUND = "sound_index_not_found", E.SOUND_NAME_NOT_FOUND = "sound_name_not_found", E.SOUND_NAME_ALREADY_EXISTS = "sound_name_already_exists", E.SOUND_NOT_ALLOWED_ERROR = "sound_not_allowed_error", E.SOUND_USE_NOT_READY = "sound_use_not_ready", E.COSTUME_INDEX_NOT_FOUND = "costume_index_not_found", E.COSTUME_NAME_NOT_FOUND = "costume_name_not_found", E.COSTUME_SWITCH_NOT_READY = "costume_switch_not_ready", E.STAMP_NOT_READY = "stamp_not_ready", E.STAMP_COSTUME_NOT_FOUND = "stamp_costume_not_found", E.COLLIDER_NAME_NOT_FOUND = "collider_name_not_found", E.messages = { script_error: { ru: "Произошла ошибка, ознакомьтесь с подробной информацией в консоли.", en: "An error has occurred, take a look at the details in the console." }, mistake_method: { ru: '${className}: Метод или свойство "${prop}" не найдено', en: '${className}: Method "${prop}" not found' }, mistake_method_with_closest: { ru: '${className}: Метод или свойство "${prop}" не найдено. Возможно вы имели ввиду: ${closestString}?', en: '${className}: Method "${prop}" not found. Did you mean: ${closestString}?' }, need_stage_before_run_game: { ru: "Вам нужно создать экземпляр Stage перед запуском игры.", en: "You need create Stage instance before run game." }, need_create_stage_before_sprite: { ru: "Вам нужно создать экземпляр класса Stage перед экземпляром класса Sprite.", en: "You need create Stage instance before Sprite instance." }, costume_not_loaded: { ru: 'Изображение для костюма "${costumePath}" не было загружено. Проверьте правильность пути.', en: 'Costume image "${costumePath}" was not loaded. Check that the path is correct.' }, background_not_loaded: { ru: 'Изображение для фона "${backgroundPath}" не было загружено. Проверьте правильность пути.', en: 'Background image "${backgroundPath}" was not loaded. Check that the path is correct.' }, cloned_not_ready: { ru: "Спрайт не может быть клонирован, потому что он еще не готов. Попробуйте использовать метод sprite.onReady()", en: "Sprite cannot be cloned because one is not ready. Try using the sprite.onReady() method." }, sound_index_not_found: { ru: 'Звук с индексом "${soundIndex}" не найден.', en: 'Sound with index "${soundIndex}" not found.' }, sound_name_not_found: { ru: 'Звук с именем "${soundName}" не найден.', en: 'Sound with name "${soundName}" not found.' }, sound_name_already_exists: { ru: 'Звук с именем "${soundName}" уже добавлен.', en: 'Sound with name "${soundName}" already exists.' }, sound_use_not_ready: { ru: "Спрайт не может использовать звуки, потому что спрайт еще не готов. Попробуйте использовать метод sprite.onReady().", en: "Sprite cannot use sounds because sprite is not ready. Try using the sprite.onReady() method." }, sound_not_allowed_error: { ru: "Воспроизведение звука заблокировано. Пользователь должен сначала взаимодействовать с игрой. Воспользуйтесь методом Game.onUserInteracted()", en: "Audio playback is blocked. The user must first interact with the game. Use the Game.onUserInteracted() method." }, costume_index_not_found: { ru: 'Костюм с индексом "${costumeIndex}" не найден.', en: 'Costume with index "${costumeIndex}" not found.' }, costume_name_not_found: { ru: 'Костюм с именем "${costumeName}" не найден.', en: 'Costume with name "${costumeName}" not found.' }, costume_switch_not_ready: { ru: "Спрайт не может изменить костюм, потому что спрайт еще не готов. Попробуйте использовать метод sprite.onReady().", en: "Sprite cannot change a costume because sprite is not ready. Try using the sprite.onReady() method." }, stamp_not_ready: { ru: "Спрайт не может создать штамп, потому что он еще не готов. Попробуйте использовать метод sprite.onReady()", en: "Sprite cannot create a stamp because sprite is not ready. Try using the sprite.onReady() method." }, stamp_costume_not_found: { ru: 'Штам не может быть создан, так как костюм с индексом "${costumeIndex}" не найден.', en: 'The stamp cannot be created because the costume with the index "${costumeIndex}" has not been found.' }, collider_name_not_found: { ru: 'Коллайдер с именем "${colliderName}" не найден.', en: 'Collider with name "${colliderName}" not found.' } };
var y = E;
var ht = class ht2 {
  static getChar(t) {
    return ht2.map[t];
  }
};
ht.map = ["", "", "", "CANCEL", "", "", "HELP", "", "BACK_SPACE", "TAB", "", "", "CLEAR", "ENTER", "ENTER_SPECIAL", "", "SHIFT", "CONTROL", "ALT", "PAUSE", "CAPS_LOCK", "KANA", "EISU", "JUNJA", "FINAL", "HANJA", "", "ESCAPE", "CONVERT", "NONCONVERT", "ACCEPT", "MODECHANGE", "SPACE", "PAGE_UP", "PAGE_DOWN", "END", "HOME", "LEFT", "UP", "RIGHT", "DOWN", "SELECT", "PRINT", "EXECUTE", "PRINTSCREEN", "INSERT", "DELETE", "", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "COLON", "SEMICOLON", "LESS_THAN", "EQUALS", "GREATER_THAN", "QUESTION_MARK", "AT", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "OS_KEY", "", "CONTEXT_MENU", "", "SLEEP", "NUMPAD0", "NUMPAD1", "NUMPAD2", "NUMPAD3", "NUMPAD4", "NUMPAD5", "NUMPAD6", "NUMPAD7", "NUMPAD8", "NUMPAD9", "MULTIPLY", "ADD", "SEPARATOR", "SUBTRACT", "DECIMAL", "DIVIDE", "F1", "F2", "F3", "F4", "F5", "F6", "F7", "F8", "F9", "F10", "F11", "F12", "F13", "F14", "F15", "F16", "F17", "F18", "F19", "F20", "F21", "F22", "F23", "F24", "", "", "", "", "", "", "", "", "NUM_LOCK", "SCROLL_LOCK", "WIN_OEM_FJ_JISHO", "WIN_OEM_FJ_MASSHOU", "WIN_OEM_FJ_TOUROKU", "WIN_OEM_FJ_LOYA", "WIN_OEM_FJ_ROYA", "", "", "", "", "", "", "", "", "", "CIRCUMFLEX", "EXCLAMATION", "DOUBLE_QUOTE", "HASH", "DOLLAR", "PERCENT", "AMPERSAND", "UNDERSCORE", "OPEN_PAREN", "CLOSE_PAREN", "ASTERISK", "PLUS", "PIPE", "HYPHEN_MINUS", "OPEN_CURLY_BRACKET", "CLOSE_CURLY_BRACKET", "TILDE", "", "", "", "", "VOLUME_MUTE", "VOLUME_DOWN", "VOLUME_UP", "", "", "SEMICOLON", "EQUALS", "COMMA", "MINUS", "PERIOD", "SLASH", "BACK_QUOTE", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "OPEN_BRACKET", "BACK_SLASH", "CLOSE_BRACKET", "QUOTE", "", "META", "ALTGR", "", "WIN_ICO_HELP", "WIN_ICO_00", "", "WIN_ICO_CLEAR", "", "", "WIN_OEM_RESET", "WIN_OEM_JUMP", "WIN_OEM_PA1", "WIN_OEM_PA2", "WIN_OEM_PA3", "WIN_OEM_WSCTRL", "WIN_OEM_CUSEL", "WIN_OEM_ATTN", "WIN_OEM_FINISH", "WIN_OEM_COPY", "WIN_OEM_AUTO", "WIN_OEM_ENLW", "WIN_OEM_BACKTAB", "ATTN", "CRSEL", "EXSEL", "EREOF", "PLAY", "ZOOM", "", "PA1", "WIN_OEM_CLEAR", ""];
var P = ht;
var ct = class {
  constructor() {
    this.keys = {};
    document.addEventListener("keydown", (t) => {
      let e = P.getChar(t.keyCode);
      this.keys[e] = true;
    }), document.addEventListener("keyup", (t) => {
      let e = P.getChar(t.keyCode);
      delete this.keys[e];
    });
  }
  keyPressed(t) {
    return this.keys[t.toUpperCase()] !== void 0;
  }
  keyDown(t, e) {
    document.addEventListener("keydown", (i) => {
      let s = P.getChar(i.keyCode);
      t.toUpperCase() == s && e(i);
    });
  }
  keyUp(t, e) {
    document.addEventListener("keyup", (i) => {
      let s = P.getChar(i.keyCode);
      t.toUpperCase() == s && e(i);
    });
  }
};
var dt = class {
  constructor(t) {
    this.x = 0;
    this.y = 0;
    this.isDown = false;
    document.addEventListener("mousedown", () => {
      this.isDown = true, this.lastStage = t.getActiveStage();
    }), document.addEventListener("mouseup", () => {
      this.isDown = false;
    }), document.addEventListener("mousemove", (e) => {
      this.x = t.correctMouseX(e.clientX), this.y = t.correctMouseY(e.clientY);
    }), this.point = new L(this.x, this.y);
  }
  getPoint() {
    return this.point.x = this.x, this.point.y = this.y, this.point;
  }
  isMouseDown(t) {
    return this.isDown && t === this.lastStage;
  }
  clearMouseDown() {
    this.isDown = false;
  }
};
var k = class u3 {
  constructor() {
    this.data = {};
  }
  static getInstance() {
    return this.instance || (this.instance = new u3()), this.instance;
  }
  set(t, e) {
    this.data[t] = e;
  }
  has(t) {
    return this.data[t] !== void 0;
  }
  get(t) {
    return this.data[t];
  }
};
var ut = class {
  constructor(t, e, i) {
    this.canvas = t, this.setEnvironmentStyles(), this.setCanvasSize(e, i), this.canvasRect = t.getBoundingClientRect(), window.addEventListener("resize", () => {
      this.setCanvasSize(e, i), this.canvasRect = t.getBoundingClientRect();
    });
  }
  setEnvironmentStyles() {
    document.body.style.margin = "0", document.body.style.height = "100vh", document.body.style.padding = "0", document.body.style.overflow = "hidden";
  }
  setCanvasSize(t, e) {
    this.canvas.width = t || document.body.clientWidth, this.canvas.height = e || document.body.clientHeight;
  }
};
var mt = class u4 {
  constructor(t) {
    this.game = t;
  }
  createValidator(t, e) {
    let i = this.game;
    return new Proxy(t, { get(s, n) {
      if (n in s) return s[n];
      if (typeof n == "symbol" || n.startsWith("_")) return;
      let r = Object.getOwnPropertyNames(Object.getPrototypeOf(s)).filter((a) => a !== "constructor"), o = u4.findClosestMethods(n.toString(), r);
      if (o.length) {
        let a = o.join(", ");
        i.throwError(y.MISTAKE_METHOD_WITH_CLOSEST, { className: e, prop: n, closestString: a });
      } else i.throwError(y.MISTAKE_METHOD, { className: e, prop: n });
    } });
  }
  static findClosestMethods(t, e, i = 2) {
    return e.map((s) => ({ name: s, distance: u4.levenshteinDistance(t.toLowerCase(), s.toLowerCase()) })).filter(({ distance: s }) => s <= i).sort((s, n) => s.distance - n.distance).map(({ name: s }) => s).slice(0, 3);
  }
  static levenshteinDistance(t, e) {
    let i = Array(t.length + 1).fill(null).map(() => Array(e.length + 1).fill(0));
    for (let s = 0; s <= t.length; s++) i[s][0] = s;
    for (let s = 0; s <= e.length; s++) i[0][s] = s;
    for (let s = 1; s <= t.length; s++) for (let n = 1; n <= e.length; n++) {
      let r = t[s - 1] === e[n - 1] ? 0 : 1;
      i[s][n] = Math.min(i[s - 1][n] + 1, i[s][n - 1] + 1, i[s - 1][n - 1] + r);
    }
    return i[t.length][e.length];
  }
};
var W = class {
  constructor() {
    this.ready = false;
  }
  get width() {
    return this.image instanceof HTMLCanvasElement ? this.image.width : 0;
  }
  get height() {
    return this.image instanceof HTMLCanvasElement ? this.image.height : 0;
  }
};
var H = class {
  constructor() {
    this.callbacksMap = /* @__PURE__ */ new Map();
    this.eventTarget = new EventTarget();
  }
  once(t, e, i) {
    if (this.callbacksMap.get(t)) return false;
    let s = (n) => {
      typeof i == "function" ? i(n) : i.handleEvent(n), this.eventTarget.removeEventListener(e, s), this.remove(t);
    };
    return this.eventTarget.addEventListener(e, s), this.callbacksMap.set(t, { type: e, callback: s }), true;
  }
  on(t, e, i) {
    return this.callbacksMap.get(t) ? false : (this.eventTarget.addEventListener(e, i), this.callbacksMap.set(t, { type: e, callback: i }), true);
  }
  emit(t, e) {
    this.eventTarget.dispatchEvent(new CustomEvent(t, { detail: e }));
  }
  remove(t) {
    let e = this.callbacksMap.get(t);
    return e ? (this.eventTarget.removeEventListener(e.type, e.callback), this.callbacksMap.delete(t), true) : false;
  }
  removeByType(t) {
    this.callbacksMap.forEach((e, i) => {
      t === e.type && (this.eventTarget.removeEventListener(e.type, e.callback), this.callbacksMap.delete(i));
    });
  }
  clearAll() {
    this.callbacksMap.forEach((t) => {
      this.eventTarget.removeEventListener(t.type, t.callback);
    }), this.callbacksMap.clear();
  }
};
var K = class K2 {
  constructor(t = null, e = null, i = null, s = true, n = "ru") {
    this.debugMode = "none";
    this.debugCollider = false;
    this.debugColor = "red";
    this.stages = [];
    this.activeStage = null;
    this.styles = null;
    this.loadedStages = 0;
    this.onReadyCallbacks = [];
    this.onUserInteractedCallbacks = [];
    this.onReadyPending = true;
    this.running = false;
    this.pendingRun = false;
    this.reportedError = false;
    this._displayErrors = true;
    this._locale = "ru";
    this._userInteracted = false;
    this._displayErrors = s, this._locale = n, this.validatorFactory = new mt(this);
    let r = this;
    if (this.displayErrors && (r = this.validatorFactory.createValidator(this, "Game")), window.onerror = () => {
      r.reportError(y.getMessage(y.SCRIPT_ERROR, r._locale));
    }, r.id = Symbol(), r.eventEmitter = new H(), r.keyboard = new ct(), i) {
      let o = document.getElementById(i);
      o instanceof HTMLCanvasElement && (r.canvas = o);
    } else r.canvas = document.createElement("canvas"), document.body.appendChild(r.canvas);
    return r.canvas.width = t, r.canvas.height = e, r.styles = new ut(r.canvas, t, e), r.mouse = new dt(r), r.context = r.canvas.getContext("2d"), k.getInstance().set("game", r), r.addListeners(), r;
  }
  addStage(t) {
    return this.stages.push(t), this;
  }
  getLastStage() {
    return this.stages.length ? this.stages[this.stages.length - 1] : null;
  }
  getActiveStage() {
    return this.activeStage ? this.activeStage : null;
  }
  run(t = null) {
    if (!t && this.stages.length && (t = this.stages[0]), t || this.throwError(y.NEED_STAGE_BEFORE_RUN_GAME), !this.running) for (let e of this.stages) e.ready();
    this.activeStage && this.activeStage.running && this.activeStage.stop(), this.running = false, this.pendingRun = true, this.activeStage = t, this.tryDoRun();
  }
  isReady() {
    return this.loadedStages == this.stages.length;
  }
  onReady(t) {
    this.onReadyCallbacks.push(t);
  }
  onUserInteracted(t) {
    this.onUserInteractedCallbacks.push(t);
  }
  stop() {
    this.activeStage && this.activeStage.running && this.activeStage.stop(), this.running = false;
  }
  get displayErrors() {
    return this._displayErrors;
  }
  get locale() {
    return this._locale;
  }
  get width() {
    return this.canvas.width;
  }
  get height() {
    return this.canvas.height;
  }
  get userInteracted() {
    return this._userInteracted;
  }
  isInsideGame(t, e) {
    return t >= 0 && t <= this.width && e >= 0 && e <= this.height;
  }
  correctMouseX(t) {
    return t - this.styles.canvasRect.left;
  }
  correctMouseY(t) {
    return t - this.styles.canvasRect.top;
  }
  keyPressed(t) {
    if (Array.isArray(t)) {
      for (let e of t) if (this.keyboard.keyPressed(e)) return true;
      return false;
    }
    return this.keyboard.keyPressed(t);
  }
  keyDown(t, e) {
    this.keyboard.keyDown(t, e);
  }
  keyUp(t, e) {
    this.keyboard.keyUp(t, e);
  }
  mouseDown() {
    return this.mouse.isMouseDown(this.activeStage);
  }
  mouseDownOnce() {
    let t = this.mouse.isMouseDown(this.activeStage);
    return this.mouse.clearMouseDown(), t;
  }
  getMousePoint() {
    return this.mouse.getPoint();
  }
  getRandom(t, e) {
    return Math.floor(Math.random() * (e - t + 1)) + t;
  }
  throwError(t, e = null, i = true) {
    let s = y.getMessage(t, this.locale, e);
    this.throwErrorRaw(s, i);
  }
  throwErrorRaw(t, e = true) {
    throw e && this.reportError(t), new Error(t);
  }
  reportError(t) {
    this._displayErrors && !this.reportedError && (alert(t), this.reportedError = true);
  }
  addListeners() {
    this.eventEmitter.on(K2.STAGE_READY_EVENT, K2.STAGE_READY_EVENT, (t) => {
      this.loadedStages++, this.tryDoOnReady();
    }), document.addEventListener("visibilitychange", () => {
      document.hidden ? this.activeStage && this.activeStage.running && this.activeStage.stop() : this.activeStage && this.activeStage.stopped && this.activeStage.run();
    }), this.userInteractionPromise = new Promise((t) => {
      document.addEventListener("click", t, { once: true }), document.addEventListener("keydown", (e) => {
        ["Control", "Shift", "CapsLock", "NumLock", "Alt", "Meta"].includes(e.key) || t(true);
      }, { once: true });
    });
  }
  tryDoOnReady() {
    if (this.isReady() && this.onReadyPending) {
      if (this.onReadyPending = false, this.onReadyCallbacks.length) {
        for (let t of this.onReadyCallbacks) t();
        this.onReadyCallbacks = [];
      }
      this.userInteractionPromise.then(() => {
        this._userInteracted = true, this.onUserInteractedCallbacks.filter((t) => (t(this), false));
      }), this.tryDoRun();
    }
  }
  tryDoRun() {
    this.pendingRun && !this.running && this.isReady() && (this.running = true, this.pendingRun = false, this.activeStage.run());
  }
};
K.STAGE_READY_EVENT = "scrubjs.stage.ready", K.STAGE_BACKGROUND_READY_EVENT = "scrubjs.stage.background_ready", K.SPRITE_READY_EVENT = "scrubjs.sprite.ready";
var D = K;
var X = class {
  constructor(t, e, i, s) {
    this.callback = t, this.state = e, this.timeout = i, this.finishCallback = s;
  }
};
var B = class {
  constructor(t, e, i) {
    this.interval = t, this.maxIterations = e, this.currentIteration = i;
  }
};
var Q = class u5 {
  constructor(t, e = 0, i = []) {
    this.name = "No name";
    this.game = null;
    this.stage = null;
    this._parentSprite = null;
    this._collidedSprite = null;
    this._original = null;
    this.costumeIndex = null;
    this.costume = null;
    this.costumes = [];
    this.costumeNames = [];
    this.sounds = [];
    this.soundNames = [];
    this.currentColliderName = null;
    this.colliders = /* @__PURE__ */ new Map();
    this.phrase = null;
    this.phraseLiveTime = null;
    this._x = 0;
    this._y = 0;
    this._pivotOffsetX = 0;
    this._pivotOffsetY = 0;
    this._width = 0;
    this._height = 0;
    this._defaultColliderNone = false;
    this._direction = 0;
    this._size = 100;
    this._centerDistance = 0;
    this._centerAngle = 0;
    this._rotateStyle = "normal";
    this._hidden = false;
    this._opacity = null;
    this._filter = null;
    this._deleted = false;
    this._stopped = true;
    this.pendingCostumeGrids = 0;
    this.pendingCostumes = 0;
    this.pendingSounds = 0;
    this._children = [];
    this.onReadyCallbacks = [];
    this.onReadyPending = true;
    this.scheduledCallbacks = [];
    this.tempScheduledCallbacks = [];
    this._drawings = [];
    this._tags = [];
    if (!k.getInstance().has("game")) throw new Error("You need create Game instance before Stage instance.");
    this.game = k.getInstance().get("game");
    let s = this;
    this.game.displayErrors && (s = this.game.validatorFactory.createValidator(this, "Sprite")), s.id = Symbol(), s.eventEmitter = new H(), s.collisionResult = new M(), s.stage = t, this.stage || (s.stage = this.game.getLastStage()), s.stage || s.game.throwError(y.NEED_CREATE_STAGE_BEFORE_SPRITE), s._layer = e, s._x = s.game.width / 2, s._y = s.game.height / 2;
    for (let n of i) s.addCostume(n);
    return s.scheduledCallbackExecutor = new Z(s), s.stage.addSprite(s), s.init(), s;
  }
  init() {
  }
  onReady(t) {
    this.onReadyCallbacks.push(t);
  }
  isReady() {
    return this.pendingCostumes === 0 && this.pendingCostumeGrids === 0 && this.pendingSounds === 0;
  }
  get deleted() {
    return this._deleted;
  }
  get stopped() {
    return this._stopped;
  }
  setParent(t) {
    return t.addChild(this), this;
  }
  addChild(t) {
    if (!this._children.includes(t)) {
      this._children.push(t), t.parent = this, t.layer = this.layer, t.x = 0, t.y = 0, t.direction = 0;
      for (let e of this.tags) t.addTag(e);
    }
    return t.parent = this, this;
  }
  removeChild(t) {
    let e = this._children.indexOf(t);
    if (e > -1) {
      let i = this._children[e];
      i.parent = null;
      for (let s of this.tags) i.removeTag(s);
      this._children.splice(e, 1);
    }
    return this;
  }
  getChildren() {
    return this._children;
  }
  set parent(t) {
    this._parentSprite = t;
  }
  get parent() {
    return this._parentSprite;
  }
  getMainSprite() {
    return this._parentSprite ? this._parentSprite.getMainSprite() : this;
  }
  switchCollider(t) {
    if (this.colliders.has(t) || this.game.throwError(y.COLLIDER_NAME_NOT_FOUND, { colliderName: t }), this.currentColliderName === t) return this;
    let e = this.collider;
    e && this.stage.collisionSystem.remove(e), this.currentColliderName = t;
    let i = this.collider;
    return this.stage.collisionSystem.insert(i), this._width = i.width, this._height = i.height, this;
  }
  setCollider(t, e, i = 0, s = 0) {
    if (e.parentSprite = this, e.offset_x = i, e.offset_y = s, this.currentColliderName === t && this.colliders.has(t)) {
      let n = this.colliders.get(t);
      this.stage.collisionSystem.remove(n), this.currentColliderName = null;
    }
    return this.colliders.set(t, e), this.updateColliderPosition(e), this.isReady() && !this.collider && this.switchCollider(t), this;
  }
  setRectCollider(t, e, i, s = 0, n = 0) {
    let r = 0;
    this._rotateStyle != "leftRight" && (r = this.globalAngleRadians);
    let o = new w(this.x, this.y, [[e / 2 * -1, i / 2 * -1], [e / 2, i / 2 * -1], [e / 2, i / 2], [e / 2 * -1, i / 2]], r, this.size / 100, this.size / 100);
    return o.width = e, o.height = i, this.setCollider(t, o, s, n), this;
  }
  setPolygonCollider(t, e, i = 0, s = 0) {
    let n = 0;
    this._rotateStyle != "leftRight" && (n = this.globalAngleRadians);
    let r = this.calculateCentroid(e), o = e.map((d) => [d[0] - r.x, d[1] - r.y]), a = new w(this.x, this.y, o, n, this.size / 100, this.size / 100), { width: l, height: h } = this.calculatePolygonSize(o);
    return a.width = l, a.height = h, this.setCollider(t, a, i, s), this;
  }
  setCircleCollider(t, e, i = 0, s = 0) {
    let n = new Y(this.x, this.y, e, this.size / 100);
    return n.width = e * 2, n.height = e * 2, this.setCollider(t, n, i, s), this;
  }
  setCostumeCollider(t, e = 0, i = 0, s = 0) {
    this.costumes[e] === void 0 && this.game.throwError(y.COSTUME_INDEX_NOT_FOUND, { costumeIndex: e });
    let n = this.costumes[e];
    return this.setRectCollider(t, n.width, n.height, i, s), this;
  }
  removeCollider(t) {
    if (t) this.removeColliderByName(t);
    else {
      let e = this.collider;
      e && this.stage.collisionSystem.remove(e), this.colliders.clear(), this.currentColliderName = null, this.defaultColliderNone = true;
    }
    return this;
  }
  removeColliderByName(t) {
    let e = this.getCollider(t);
    if (this.colliders.delete(t), this.colliders.size === 0 && (this.defaultColliderNone = true), t === this.currentColliderName && (this.stage.collisionSystem.remove(e), this.colliders.size)) {
      let i = this.colliders.keys().next().value;
      this.switchCollider(i);
    }
    return this;
  }
  getCollider(t) {
    return this.colliders.has(t) || this.game.throwError(y.COLLIDER_NAME_NOT_FOUND, { colliderName: t }), this.colliders.get(t);
  }
  hasCollider(t) {
    return this.colliders.has(t);
  }
  get collider() {
    return this.currentColliderName && this.colliders.has(this.currentColliderName) ? this.colliders.get(this.currentColliderName) : null;
  }
  get collidedSprite() {
    return this._collidedSprite;
  }
  set defaultColliderNone(t) {
    this._defaultColliderNone = t;
  }
  get defaultColliderNone() {
    return this._defaultColliderNone;
  }
  getColliders() {
    return this.colliders.entries();
  }
  cloneCollider(t) {
    let e = t.getColliders();
    for (let [i, s] of e) s instanceof Y && this.setCircleCollider(i, s.radius, s.offset_x, s.offset_y), s instanceof w && this.setPolygonCollider(i, s.points, s.offset_x, s.offset_y);
  }
  calculateCentroid(t) {
    let e = 0, i = 0;
    for (let r of t) e += r[0], i += r[1];
    let s = e / t.length, n = i / t.length;
    return { x: s, y: n };
  }
  calculatePolygonSize(t) {
    let e = t[0][0], i = t[0][1], s = t[0][0], n = t[0][1];
    for (let a of t) a[0] < e && (e = a[0]), a[0] > s && (s = a[0]), a[1] < i && (i = a[1]), a[1] > n && (n = a[1]);
    let r = s - e, o = n - i;
    return { width: r, height: o };
  }
  updateColliderPosition(t) {
    t.x = this.imageCenterX + t.center_offset_x * this.size / 100, t.y = this.imageCenterY + t.center_offset_y * this.size / 100;
  }
  updateColliderAngle() {
    let t = this.collider;
    t instanceof w && (this._rotateStyle == "leftRight" ? t.angle = 0 : t.angle = this.globalAngleRadians), t && this.updateColliderPosition(t);
  }
  updateColliderSize(t) {
    t instanceof w ? (t.scale_x = this.size / 100, t.scale_y = this.size / 100) : t instanceof Y && (t.scale = this.size / 100);
  }
  addTag(t) {
    this.hasTag(t) || this._tags.push(t);
    for (let e of this._children) e.addTag(t);
    return this;
  }
  removeTag(t) {
    let e = this._tags.indexOf(t);
    e > -1 && this._tags.splice(e, 1);
    for (let i of this._children) i.addTag(t);
    return this;
  }
  hasTag(t) {
    return this._tags.includes(t);
  }
  get tags() {
    return this._tags;
  }
  addCostume(t, e) {
    let i = new W(), s = this.costumes.length, n = ((e == null ? void 0 : e.name) ?? "Costume") + "-" + s;
    this.costumes.push(i), this.costumeNames.push(n), this.pendingCostumes++;
    let r = new Image();
    r.src = t, (e == null ? void 0 : e.alphaColor) && (r.crossOrigin = "anonymous");
    let o = () => {
      if (this.deleted) return;
      let a = this.transformImage(r, (e == null ? void 0 : e.rotate) ?? 0, (e == null ? void 0 : e.flipX) ?? false, (e == null ? void 0 : e.flipY) ?? false, (e == null ? void 0 : e.x) ?? 0, (e == null ? void 0 : e.y) ?? 0, (e == null ? void 0 : e.width) ?? r.naturalWidth, (e == null ? void 0 : e.height) ?? r.naturalHeight, (e == null ? void 0 : e.alphaColor) ?? null, (e == null ? void 0 : e.alphaTolerance) ?? 0, (e == null ? void 0 : e.crop) ?? 0, (e == null ? void 0 : e.cropTop) ?? null, (e == null ? void 0 : e.cropRight) ?? null, (e == null ? void 0 : e.cropBottom) ?? null, (e == null ? void 0 : e.cropLeft) ?? null);
      i.image = a, i.ready = true, this.pendingCostumes--, this.tryDoOnReady(), r.removeEventListener("load", o);
    };
    return r.addEventListener("load", o), r.addEventListener("error", () => {
      this.game.throwError(y.COSTUME_NOT_LOADED, { costumePath: t });
    }), this;
  }
  addCostumeGrid(t, e) {
    let i = new Image();
    i.src = t;
    let s = (e == null ? void 0 : e.name) ?? "Costume";
    this.pendingCostumeGrids++;
    let n = () => {
      i.naturalWidth, i.naturalHeight;
      let r = e.cols, o = e.rows, a = e.limit, l = e.offset, h = i.naturalWidth / r, d = i.naturalHeight / o, c = false, _ = 0, p = 0, m = 0;
      for (let f = 0; f < o; f++) {
        for (let b = 0; b < r; b++) {
          if (c = false, l !== null && l > 0 && (l--, c = true), !c) {
            if (a !== null) {
              if (a == 0) break;
              a > 0 && a--;
            }
            let v = new W();
            this.costumes.push(v), this.costumeNames.push(s + "-" + _);
            let C = this.transformImage(i, (e == null ? void 0 : e.rotate) ?? 0, (e == null ? void 0 : e.flipX) ?? false, (e == null ? void 0 : e.flipY) ?? false, p + ((e == null ? void 0 : e.x) ?? 0), m + ((e == null ? void 0 : e.y) ?? 0), (e == null ? void 0 : e.width) ?? h, (e == null ? void 0 : e.height) ?? d, (e == null ? void 0 : e.alphaColor) ?? null, (e == null ? void 0 : e.alphaTolerance) ?? 0, (e == null ? void 0 : e.crop) ?? 0, (e == null ? void 0 : e.cropTop) ?? null, (e == null ? void 0 : e.cropRight) ?? null, (e == null ? void 0 : e.cropBottom) ?? null, (e == null ? void 0 : e.cropLeft) ?? null);
            v.image = C, v.ready = true, _++;
          }
          p += h;
        }
        p = 0, m += d;
      }
      this.pendingCostumeGrids--, this.tryDoOnReady(), i.removeEventListener("load", n);
    };
    return i.addEventListener("load", n), this;
  }
  drawCostume(t, e) {
    let i = document.createElement("canvas"), s = i.getContext("2d");
    i.width = (e == null ? void 0 : e.width) ?? 100, i.height = (e == null ? void 0 : e.height) ?? 100, this.pendingCostumes++, t(s, this);
    let n = this.costumes.length, r = ((e == null ? void 0 : e.name) ?? "Costume") + "-" + n;
    Object.values(e || {}).some((l) => !!l) && (i = this.transformImage(i, (e == null ? void 0 : e.rotate) ?? 0, (e == null ? void 0 : e.flipX) ?? false, (e == null ? void 0 : e.flipY) ?? false, (e == null ? void 0 : e.x) ?? 0, (e == null ? void 0 : e.y) ?? 0, (e == null ? void 0 : e.width) ?? i.width, (e == null ? void 0 : e.height) ?? i.height, (e == null ? void 0 : e.alphaColor) ?? null, (e == null ? void 0 : e.alphaTolerance) ?? 0, (e == null ? void 0 : e.crop) ?? 0, (e == null ? void 0 : e.cropTop) ?? null, (e == null ? void 0 : e.cropRight) ?? null, (e == null ? void 0 : e.cropBottom) ?? null, (e == null ? void 0 : e.cropLeft) ?? null));
    let a = new W();
    return a.image = i, a.ready = true, this.costumes.push(a), this.costumeNames.push(r + "-" + n), this.pendingCostumes--, this;
  }
  removeCostume(t) {
    return this.costumes[t] === void 0 && this.game.throwError(y.COSTUME_INDEX_NOT_FOUND, { costumeIndex: t }), this.costumes.splice(t, 1), this.costumeNames.splice(t, 1), this.costumeIndex === t && (this.costumeIndex = null, this.costumes.length > 0 ? this.nextCostume() : this.costume = null), this;
  }
  switchCostume(t) {
    if (this.deleted) return;
    this.isReady() || this.game.throwError(y.COSTUME_SWITCH_NOT_READY);
    let e = this.costumes[t];
    return e instanceof W && e.ready && (this.costumeIndex = t, this.costume = e), this;
  }
  switchCostumeByName(t) {
    this.isReady() || this.game.throwError(y.COSTUME_SWITCH_NOT_READY);
    let e = this.costumeNames.indexOf(t);
    return e > -1 ? this.switchCostume(e) : this.game.throwError(y.COSTUME_NAME_NOT_FOUND, { costumeName: t }), this;
  }
  nextCostume(t = 0, e) {
    if (this.deleted) return;
    this.isReady() || this.game.throwError(y.COSTUME_SWITCH_NOT_READY);
    let i = this.costumes.length - 1;
    t = Math.min(i, Math.max(0, t)), e = Math.min(i, Math.max(0, e ?? i));
    let s = this.costumeIndex + 1;
    return (s > e || s < t) && (s = t), s !== this.costumeIndex && this.switchCostume(s), s;
  }
  prevCostume(t = 0, e) {
    if (this.deleted) return;
    this.isReady() || this.game.throwError(y.COSTUME_SWITCH_NOT_READY);
    let i = this.costumes.length - 1;
    t = Math.min(i, Math.max(0, t)), e = Math.min(i, Math.max(0, e ?? i));
    let s = this.costumeIndex - 1;
    return (s < t || s > e) && (s = e), s !== this.costumeIndex && this.switchCostume(s), s;
  }
  getCostume() {
    return this.costume;
  }
  getCostumeName() {
    return this.costumeIndex === null ? "No costume" : this.costumeNames[this.costumeIndex];
  }
  getCostumeIndex() {
    return this.costumeIndex;
  }
  transformImage(t, e, i = false, s = false, n = 0, r = 0, o = null, a = null, l = null, h = 0, d = 0, c = null, _ = null, p = null, m = null) {
    c = c ?? d, _ = _ ?? d, p = p ?? d, m = m ?? d, n += _, o -= _, o -= m, r += c, a -= c, a -= p;
    let f = document.createElement("canvas"), b = f.getContext("2d"), v = e * Math.PI / 180, C = o ?? (t instanceof HTMLImageElement ? t.naturalWidth : t.width), S = a ?? (t instanceof HTMLImageElement ? t.naturalHeight : t.height);
    if (e) {
      let F = Math.abs(Math.cos(v)), J = Math.abs(Math.sin(v));
      C = C * F + S * J, S = C * J + S * F;
    }
    f.width = Math.ceil(C), f.height = Math.ceil(S), b.translate(f.width / 2, f.height / 2), e && b.rotate(v), (i || s) && b.scale(i ? -1 : 1, s ? -1 : 1);
    let x = -o / 2, N = -a / 2;
    return b.drawImage(t, n, r, o, a, x, N, o, a), l && (f = this.setAlpha(f, l, h ?? 0)), f;
  }
  setAlpha(t, e, i = 0) {
    let s = document.createElement("canvas"), n = s.getContext("2d");
    if (!n) throw new Error("Canvas context is not available");
    s.width = t.width, s.height = t.height;
    let r = t.getContext("2d").getImageData(0, 0, t.width, t.height), o = r.data, a;
    if (typeof e == "string") {
      if (a = this.hexToRgb(e), !a) throw new Error(`Invalid HEX color: ${e}`);
    } else a = e;
    for (let l = 0; l < o.length; l += 4) {
      let h = o[l], d = o[l + 1], c = o[l + 2];
      Math.abs(h - a.r) <= i && Math.abs(d - a.g) <= i && Math.abs(c - a.b) <= i && (o[l + 3] = 0);
    }
    return n.putImageData(r, 0, 0), s;
  }
  hexToRgb(t) {
    if (t = t.replace(/^#/, ""), t.length === 3 && (t = t.split("").map((i) => i + i).join("")), t.length !== 6) return null;
    let e = parseInt(t, 16);
    return { r: e >> 16 & 255, g: e >> 8 & 255, b: e & 255 };
  }
  cloneCostume(t, e) {
    this.costumes.push(t), this.costumeNames.push(e);
  }
  addSound(t, e) {
    this.soundNames.includes(e) && this.game.throwError(y.SOUND_NAME_ALREADY_EXISTS, { soundName: e });
    let i = new Audio();
    i.src = t, this.sounds.push(i), this.soundNames.push(e), this.pendingSounds++, i.load();
    let s = () => {
      this.pendingSounds--, this.tryDoOnReady(), i.removeEventListener("loadedmetadata", s);
    };
    return i.addEventListener("loadedmetadata", s), this;
  }
  removeSound(t) {
    let e = this.soundNames.indexOf(t);
    return e < 0 && this.game.throwError(y.SOUND_NAME_NOT_FOUND, { soundName: t }), this.sounds.splice(e, 1), this;
  }
  playSound(t, e = {}) {
    let i = this.getSound(t);
    this.doPlaySound(i, e);
  }
  startSound(t, e = {}) {
    let i = this.cloneSound(t);
    return this.doPlaySound(i, e), i;
  }
  pauseSound(t) {
    this.getSound(t).pause();
  }
  getSound(t) {
    this.isReady() || this.game.throwError(y.SOUND_USE_NOT_READY);
    let e = this.soundNames.indexOf(t);
    e < 0 && this.game.throwError(y.SOUND_NAME_NOT_FOUND, { soundName: t });
    let i = this.sounds[e];
    return i instanceof Audio || this.game.throwError(y.SOUND_INDEX_NOT_FOUND, { soundIndex: e }), i;
  }
  cloneSound(t) {
    let e = this.getSound(t);
    return new Audio(e.src);
  }
  doPlaySound(t, e = {}) {
    e.volume !== void 0 && (t.volume = e.volume), e.currentTime !== void 0 && (t.currentTime = e.currentTime), e.loop !== void 0 && (t.loop = e.loop);
    let i = t.play();
    i !== void 0 && i.catch((s) => {
      s.name === "NotAllowedError" ? this.game.throwError(y.SOUND_NOT_ALLOWED_ERROR, {}, false) : console.error("Audio playback error:", s);
    });
  }
  stamp(t, e = true) {
    this.isReady() || this.game.throwError(y.STAMP_NOT_READY), t = t ?? this.costumeIndex, this.costumes[t] || this.game.throwError(y.STAMP_COSTUME_NOT_FOUND, { costumeIndex: t });
    let i = this.costumes[t];
    i.image instanceof HTMLCanvasElement || this.game.throwErrorRaw("The image inside the costume was not found.");
    let s = 0;
    e && this._rotateStyle === "normal" && (s = this.direction), this.stage.stampImage(i.image, this.x, this.y, s);
  }
  pen(t) {
    this._drawings.push(t);
  }
  get drawings() {
    return this._drawings;
  }
  set opacity(t) {
    t === null ? this._opacity = null : this._opacity = Math.min(1, Math.max(0, t));
  }
  get opacity() {
    return this._opacity;
  }
  set filter(t) {
    this._filter = t;
  }
  get filter() {
    return this._filter;
  }
  set rotateStyle(t) {
    this._rotateStyle = t;
    for (let e of this._children) e.rotateStyle = t;
  }
  get rotateStyle() {
    return this._rotateStyle;
  }
  set layer(t) {
    this.stage.changeSpriteLayer(this, this._layer, t), this._layer = t;
    for (let e of this._children) e.layer = e.layer + this._layer;
  }
  get layer() {
    return this._layer;
  }
  set hidden(t) {
    this._hidden = t;
    for (let e of this._children) e.hidden = t;
  }
  get hidden() {
    return this._hidden;
  }
  say(t, e) {
    if (this.phrase = this.name + ": " + t, this.phraseLiveTime = null, e) {
      let i = (/* @__PURE__ */ new Date()).getTime();
      this.phraseLiveTime = i + e;
    }
  }
  getPhrase() {
    if (this.phrase) {
      if (this.phraseLiveTime === null) return this.phrase;
      let t = (/* @__PURE__ */ new Date()).getTime();
      if (this.phraseLiveTime > t) return this.phrase;
      this.phrase = null, this.phraseLiveTime = null;
    }
    return null;
  }
  move(t) {
    let e = this.globalAngleRadians;
    this.x += t * Math.sin(e), this.y -= t * Math.cos(e);
  }
  pointForward(t) {
    let e = t.globalX ? t.globalX : t.x, i = t.globalY ? t.globalY : t.y;
    this.globalDirection = Math.atan2(this.globalY - i, this.globalX - e) / Math.PI * 180 - 90;
  }
  getDistanceTo(t) {
    let e = t.globalX ? t.globalX : t.x, i = t.globalY ? t.globalY : t.y;
    return Math.sqrt(Math.abs(this.globalX - e) + Math.abs(this.globalY - i));
  }
  bounceOnEdge() {
    (this.touchTopEdge() || this.touchBottomEdge()) && (this.direction = 180 - this.direction), (this.touchLeftEdge() || this.touchRightEdge()) && (this.direction *= -1);
  }
  set x(t) {
    this._x = t, this._children.length && this.updateCenterParams();
    let e = this.collider;
    e && this.updateColliderPosition(e);
    for (let i of this._children) i.collider && i.updateColliderPosition(i.collider);
  }
  get x() {
    return this._x;
  }
  set y(t) {
    this._y = t, this._children.length && this.updateCenterParams();
    let e = this.collider;
    e && this.updateColliderPosition(e);
    for (let i of this._children) i.collider && i.updateColliderPosition(i.collider);
  }
  get y() {
    return this._y;
  }
  get globalX() {
    return this._parentSprite ? this._rotateStyle === "leftRight" || this._rotateStyle === "none" ? this._parentSprite.imageCenterX + this._x * this.size / 100 : this._parentSprite.imageCenterX + this.distanceToParent * Math.cos(this.angleToParent - this._parentSprite.globalAngleRadians) * this.size / 100 : this._x;
  }
  get globalY() {
    return this._parentSprite ? this._rotateStyle === "leftRight" || this._rotateStyle === "none" ? this._parentSprite.imageCenterY + this._y : this._parentSprite.imageCenterY - this.distanceToParent * Math.sin(this.angleToParent - this._parentSprite.globalAngleRadians) * this.size / 100 : this._y;
  }
  get imageCenterX() {
    if (this._rotateStyle === "leftRight" || this._rotateStyle === "none") {
      let t = this._direction > 180 && this._rotateStyle === "leftRight" ? -1 : 1;
      return this.globalX - this._pivotOffsetX * t * this.size / 100;
    }
    return this.globalX + Math.cos(this._centerAngle - this.globalAngleRadians) * this._centerDistance * this.size / 100;
  }
  get imageCenterY() {
    return this._rotateStyle === "leftRight" || this._rotateStyle === "none" ? this.globalY - this._pivotOffsetY * this.size / 100 : this.globalY - Math.sin(this._centerAngle - this.globalAngleRadians) * this._centerDistance * this.size / 100;
  }
  get realX() {
    return this.x - this.width / 2;
  }
  get realY() {
    return this.y - this.height / 2;
  }
  get rightX() {
    let t = this.collider, e = t ? t.center_offset_x * this.size / 100 : 0;
    return this.imageCenterX + this.width / 2 + e;
  }
  set rightX(t) {
    let e = this.collider, i = e ? e.center_offset_x * this.size / 100 : 0;
    this.x = t - this.width / 2 - i;
  }
  get leftX() {
    let t = this.collider, e = t ? t.center_offset_x * this.size / 100 : 0;
    return this.imageCenterX - this.width / 2 + e;
  }
  set leftX(t) {
    let e = this.collider, i = e ? e.center_offset_x * this.size / 100 : 0;
    this.x = t + this.width / 2 + i;
  }
  get topY() {
    let t = this.collider, e = t ? t.center_offset_y * this.size / 100 : 0;
    return this.imageCenterY - this.height / 2 + e;
  }
  set topY(t) {
    let e = this.collider, i = e ? e.center_offset_y * this.size / 100 : 0;
    this.y = t + this.height / 2 + i;
  }
  get bottomY() {
    let t = this.collider, e = t ? t.center_offset_y * this.size / 100 : 0;
    return this.imageCenterY + this.height / 2 + e;
  }
  set bottomY(t) {
    let e = this.collider, i = e ? e.center_offset_y * this.size / 100 : 0;
    this.y = t - this.height / 2 - i;
  }
  get width() {
    if (this.collider instanceof w && this._rotateStyle === "normal") {
      let t = this.globalAngleRadians;
      return Math.abs(this.sourceWidth * Math.cos(t)) + Math.abs(this.sourceHeight * Math.sin(t));
    }
    return this.sourceWidth;
  }
  get height() {
    if (this.collider instanceof w && this._rotateStyle === "normal") {
      let t = this.globalAngleRadians;
      return Math.abs(this.sourceWidth * Math.sin(t)) + Math.abs(this.sourceHeight * Math.cos(t));
    }
    return this.sourceHeight;
  }
  get sourceWidth() {
    return this._width * this.size / 100;
  }
  get sourceHeight() {
    return this._height * this.size / 100;
  }
  set size(t) {
    this._size = t;
    let e = this.collider;
    e && this.updateColliderSize(e);
    for (let i of this._children) i.size = t;
  }
  get size() {
    return this._size;
  }
  set direction(t) {
    if (t * 0 === 0) {
      t = t % 360, t < 0 && (t += 360), this._direction = t > 360 ? t - 360 : t, this.updateColliderAngle();
      for (let e of this._children) e.updateColliderAngle();
    }
  }
  get direction() {
    return this._direction;
  }
  set globalDirection(t) {
    this.direction = this._parentSprite ? t - this._parentSprite.direction : t;
  }
  get globalDirection() {
    return this._parentSprite ? this._parentSprite.direction + this.direction : this.direction;
  }
  get globalAngleRadians() {
    return this.globalDirection * Math.PI / 180;
  }
  get angleToParent() {
    return -Math.atan2(this.y, this.x);
  }
  get distanceToParent() {
    return Math.hypot(this.x, this.y);
  }
  setPivotOffset(t = 0, e = 0) {
    return this.pivotOffsetX = t, this.pivotOffsetY = e, this;
  }
  set pivotOffsetX(t) {
    let e = this.x;
    this._pivotOffsetX = t, this.updateCenterParams(), this.x = e;
  }
  get pivotOffsetX() {
    return this._pivotOffsetX;
  }
  set pivotOffsetY(t) {
    let e = this.y;
    this._pivotOffsetY = t, this.updateCenterParams(), this.y = e;
  }
  get pivotOffsetY() {
    return this._pivotOffsetY;
  }
  updateCenterParams() {
    this._centerDistance = Math.hypot(this._pivotOffsetX, this._pivotOffsetY), this._centerAngle = -Math.atan2(-this._pivotOffsetY, -this._pivotOffsetX);
  }
  touchSprite(t, e = true) {
    if (this._collidedSprite = null, t.hidden || this.hidden || t.stopped || this.stopped || t.deleted || this.deleted) return false;
    let i = this.collider, s = t.collider;
    if (i && s && i.collides(s, this.collisionResult)) return true;
    if (i) {
      for (let r of t.getChildren()) if (this.touchSprite(r, false)) return true;
    }
    if (!e) return false;
    for (let r of this._children) {
      if (s && r.touchSprite(t)) return this._collidedSprite = r, true;
      for (let o of t.getChildren()) if (r.touchSprite(o)) return this._collidedSprite = r, true;
    }
    return false;
  }
  touchSprites(t, e = true) {
    if (this.hidden || this.stopped || this.deleted) return false;
    for (let i of t) if (this.touchSprite(i, e)) return true;
    return false;
  }
  touchMouse(t = true) {
    return this.touchPoint(this.game.getMousePoint(), t);
  }
  touchPoint(t, e = true) {
    if (this._collidedSprite = null, this.hidden || this.stopped || this.deleted) return false;
    let i = this.collider;
    if (i && i.collides(t, this.collisionResult)) return true;
    if (e) {
      for (let n of this._children) if (n.touchPoint(n.game.getMousePoint())) return this._collidedSprite = n.otherSprite, true;
    }
    return false;
  }
  touchEdge(t = true) {
    let e = this.getPureCollisionResult();
    if (this._collidedSprite = null, this.hidden || this.stopped || this.deleted) return false;
    if (this.collider) {
      let i = this.game.width, s = this.game.height;
      if (this.topY < 0) return e.collision = true, e.overlap = -this.topY, e.overlap_y = -1, true;
      if (this.bottomY > s) return e.collision = true, e.overlap = this.bottomY - s, e.overlap_y = 1, true;
      if (this.leftX < 0) return e.collision = true, e.overlap = -this.leftX, e.overlap_x = -1, true;
      if (this.rightX > i) return e.collision = true, e.overlap = this.rightX - i, e.overlap_x = 1, true;
    }
    if (t) {
      for (let i of this._children) if (i.touchEdge()) return this._collidedSprite = i, true;
    }
    return false;
  }
  touchTopEdge(t = true) {
    if (this.clearCollisionResult(), this._collidedSprite = null, this.hidden || this.stopped || this.deleted) return false;
    if (this.collider && this.topY < 0) return this.collisionResult.collision = true, this.collisionResult.overlap = -this.topY, this.collisionResult.overlap_y = -1, true;
    if (t) {
      for (let e of this._children) if (e.touchTopEdge()) return this._collidedSprite = e, true;
    }
    return false;
  }
  touchBottomEdge(t = true) {
    if (this.clearCollisionResult(), this._collidedSprite = null, this.hidden || this.stopped || this.deleted) return false;
    if (this.collider && this.bottomY > this.game.height) return this.collisionResult.collision = true, this.collisionResult.overlap = this.bottomY - this.game.height, this.collisionResult.overlap_y = 1, true;
    if (t) {
      for (let e of this._children) if (e.touchBottomEdge()) return this._collidedSprite = e, true;
    }
    return false;
  }
  touchLeftEdge(t = true) {
    if (this.clearCollisionResult(), this._collidedSprite = null, this.hidden || this.stopped || this.deleted) return false;
    if (this.collider && this.leftX < 0) return this.collisionResult.collision = true, this.collisionResult.overlap = -this.leftX, this.collisionResult.overlap_x = -1, true;
    if (t) {
      for (let e of this._children) if (e.touchLeftEdge()) return this._collidedSprite = e, true;
    }
    return false;
  }
  touchRightEdge(t = true) {
    if (this.clearCollisionResult(), this._collidedSprite = null, this.hidden || this.stopped || this.deleted) return false;
    if (this.collider && this.rightX > this.game.width) return this.collisionResult.collision = true, this.collisionResult.overlap = this.rightX - this.game.width, this.collisionResult.overlap_x = 1, true;
    if (t) {
      for (let e of this._children) if (e.touchRightEdge()) return this._collidedSprite = e, true;
    }
    return false;
  }
  touchTag(t, e = true) {
    if (this.clearCollisionResult(), this._collidedSprite = null, this.hidden || this.stopped || this.deleted) return false;
    let i = this.collider;
    if (i) {
      let s = i.potentials();
      if (!s.length) return false;
      for (let n of s) {
        let r = n.parentSprite;
        if (r && r.hasTag(t) && !r.hidden && !r.stopped && !r.deleted && i.collides(n, this.collisionResult)) return true;
      }
    }
    if (e) {
      for (let s of this._children) if (s.touchTag(t)) return this._collidedSprite = s, true;
    }
    return false;
  }
  touchTagAll(t, e = true) {
    if (this.clearCollisionResult(), this._collidedSprite = null, this.hidden || this.stopped || this.deleted) return false;
    let i = [], s = this.collider;
    if (s) {
      let n = s.potentials();
      if (!n.length) return false;
      for (let r of n) {
        let o = r.parentSprite;
        o && o.hasTag(t) && !o.hidden && !o.stopped && !o.deleted && o.collider && s.collides(r, this.collisionResult) && i.push(o);
      }
    }
    if (e) for (let n of this._children) {
      let r = n.touchTagAll(t);
      if (r && !r.length) for (let o of r) i.push(o);
    }
    return i.length ? i : false;
  }
  touchAnySprite(t = true) {
    if (this.clearCollisionResult(), this._collidedSprite = null, this.hidden || this.stopped || this.deleted) return false;
    let e = this.collider;
    if (e) {
      let i = e.potentials();
      if (!i.length) return false;
      for (let s of i) {
        let n = s.parentSprite;
        if (!n.hidden && !n.stopped && !n.deleted && e.collides(s, this.collisionResult)) return true;
      }
    }
    if (t) {
      for (let i of this._children) if (i.touchAnySprite()) return this._collidedSprite = i, true;
    }
    return false;
  }
  get overlap() {
    return this._collidedSprite ? this._collidedSprite.overlap : this.collisionResult.collision ? this.collisionResult.overlap : 0;
  }
  get overlapX() {
    return this._collidedSprite ? this._collidedSprite.overlapX : this.collisionResult.collision ? this.collisionResult.overlap_x * this.collisionResult.overlap : 0;
  }
  get overlapY() {
    return this._collidedSprite ? this._collidedSprite.overlapY : this.collisionResult.collision ? this.collisionResult.overlap_y * this.collisionResult.overlap : 0;
  }
  get otherSprite() {
    return this.collisionResult.collision ? this.collisionResult.b.parentSprite : null;
  }
  get otherMainSprite() {
    return this.collisionResult.collision ? this.collisionResult.b.parentSprite.getMainSprite() : null;
  }
  clearCollisionResult() {
    this.collisionResult.collision = false, this.collisionResult.a = null, this.collisionResult.b = null, this.collisionResult.a_in_b = false, this.collisionResult.b_in_a = false, this.collisionResult.overlap = 0, this.collisionResult.overlap_x = 0, this.collisionResult.overlap_y = 0;
  }
  getPureCollisionResult() {
    return this.clearCollisionResult(), this.collisionResult;
  }
  timeout(t, e) {
    this.repeat(t, 1, null, e, void 0);
  }
  repeat(t, e, i, s, n) {
    let r = new B(i, e, 0);
    return s && (s = Date.now() + s), this.tempScheduledCallbacks.push(new X(t, r, s, n)), r;
  }
  forever(t, e, i, s) {
    let n = new B(e);
    return i && (i = Date.now() + i), this.tempScheduledCallbacks.push(new X(t, n, i, s)), n;
  }
  update(t) {
    this.deleted || (this.tempScheduledCallbacks.length && (this.scheduledCallbacks = this.scheduledCallbacks.concat(this.tempScheduledCallbacks), this.tempScheduledCallbacks = []), this.scheduledCallbacks = this.scheduledCallbacks.filter(this.scheduledCallbackExecutor.execute(Date.now(), t)));
  }
  run() {
    this._stopped = false;
  }
  stop() {
    this._stopped = true;
  }
  ready() {
    this.tryDoOnReady();
  }
  get original() {
    return this._original;
  }
  setOriginal(t) {
    this._original = t;
  }
  createClone(t) {
    this.isReady() || this.game.throwError(y.CLONED_NOT_READY), t || (t = this.stage);
    let e = new u5(t, this.layer);
    e.setOriginal(this), e.name = this.name, e._rotateStyle = this._rotateStyle, e.x = this.x, e.y = this.y, e.pivotOffsetX = this.pivotOffsetX, e.pivotOffsetY = this.pivotOffsetY, e.direction = this.direction, e.size = this.size, e.hidden = this.hidden, e._deleted = this.deleted, e._stopped = this.stopped, e._tags.push(...this.tags), e.defaultColliderNone = this.defaultColliderNone;
    for (let i = 0; i < this.costumes.length; i++) e.cloneCostume(this.costumes[i], this.costumeNames[i]);
    e.switchCostume(this.costumeIndex);
    for (let [i, s] of this.sounds.entries()) e.sounds.push(s), e.soundNames.push(this.soundNames[i]);
    e.currentColliderName = null, e.cloneCollider(this), this.currentColliderName && e.switchCollider(this.currentColliderName);
    for (let i of this._children) {
      let s = i.createClone();
      e.addChild(s), s.x = i.x, s.y = i.y, s.direction = i.direction;
    }
    return e.ready(), e;
  }
  delete() {
    if (this.deleted) return;
    this.stage.removeSprite(this, this.layer), this.eventEmitter.clearAll(), this.removeCollider(), this.scheduledCallbackExecutor = null;
    for (let e of this._children) e.delete();
    let t = Object.keys(this);
    for (let e = 0; e < t.length; e++) delete this[t[e]];
    this.costumes = [], this.costumeNames = [], this.sounds = [], this.soundNames = [], this.onReadyCallbacks = [], this.tempScheduledCallbacks = [], this.scheduledCallbacks = [], this._children = [], this._deleted = true;
  }
  deleteClones() {
    this.stage.getSprites().filter((e) => e.original === this).forEach((e) => e.delete());
  }
  tryDoOnReady() {
    if (this.onReadyPending && this.isReady()) {
      if (this.onReadyPending = false, this.costumes.length && this.costume === null && this.switchCostume(0), !this.defaultColliderNone && this.colliders.size === 0 && this.costumes.length) {
        let t = "main";
        this.setCostumeCollider(t, 0), this.switchCollider(t), this.updateColliderPosition(this.collider), this.updateColliderSize(this.collider);
      }
      if (!this.collider && this.colliders.size) {
        let t = this.colliders.keys().next().value;
        this.switchCollider(t), this.updateColliderPosition(this.collider), this.updateColliderSize(this.collider);
      }
      if (this.onReadyCallbacks.length) {
        for (let t of this.onReadyCallbacks) t();
        this.onReadyCallbacks = [];
      }
      this.stage.eventEmitter.emit(D.SPRITE_READY_EVENT, { sprite: this, stageId: this.stage.id });
    }
  }
};
var Z = class {
  constructor(t) {
    this.context = t;
  }
  execute(t, e) {
    return (i) => {
      let s = i.state;
      if (this.context instanceof Q) {
        if (this.context.deleted) return false;
        if (this.context.stopped) return true;
      }
      if (i.timeout && e && (i.timeout += e), !i.timeout || i.timeout <= t) {
        let n = i.callback.bind(this.context)(this.context, s);
        if (s.maxIterations && s.currentIteration++, n === false || i.timeout && !s.interval && !s.maxIterations || s.maxIterations && s.currentIteration >= s.maxIterations) return i.finishCallback && i.finishCallback(this.context, s), false;
        s.interval && (i.timeout = t + s.interval);
      }
      return true;
    };
  }
};
var _t = class {
  constructor() {
    this.x = 0;
    this.y = 0;
    this.zoom = 1;
    this.direction = 0;
  }
  reset() {
    this.x = 0, this.y = 0, this.zoom = 1, this.direction = 0;
  }
};
var pt = class {
  constructor(t) {
    this._direction = 0;
    this._zoom = 1;
    this.stage = t, this._x = this.stage.width / 2, this._y = this.stage.height / 2, this.updateRenderRadius(), this.changes = new _t();
  }
  set direction(t) {
    let e = t % 360;
    e = e < 0 ? e + 360 : e, this.changes.direction = e - this._direction, this._direction = e;
  }
  get direction() {
    return this._direction;
  }
  get angleDirection() {
    return this._direction * Math.PI / 180;
  }
  get width() {
    return this.stage.width / this._zoom;
  }
  get height() {
    return this.stage.height / this._zoom;
  }
  set x(t) {
    this.changes.x = t - this._x, this._x = t;
  }
  get x() {
    return this._x;
  }
  set y(t) {
    this.changes.y = t - this._y, this._y = t;
  }
  get y() {
    return this._y;
  }
  get startCornerX() {
    return this._x - this.stage.width / 2;
  }
  get startCornerY() {
    return this._y - this.stage.height / 2;
  }
  get renderRadius() {
    return this._renderRadius;
  }
  set zoom(t) {
    if (this.changes.zoom == 1) {
      let e = t < 0.1 ? 0.1 : t;
      this.changes.zoom = e / this._zoom, this._zoom = e, this.updateRenderRadius();
    }
  }
  get zoom() {
    return this._zoom;
  }
  updateRenderRadius() {
    this._renderRadius = Math.hypot(this.width, this.height) / 1.7;
  }
};
var Ot = class {
  constructor(t = null) {
    this.background = null;
    this.backgroundIndex = null;
    this.backgrounds = [];
    this.sprites = /* @__PURE__ */ new Map();
    this.drawings = /* @__PURE__ */ new Map();
    this.sounds = [];
    this.soundNames = [];
    this.addedSprites = 0;
    this.loadedSprites = 0;
    this.pendingBackgrounds = 0;
    this.pendingSounds = 0;
    this.pendingRun = false;
    this.onReadyPending = true;
    this.onReadyCallbacks = [];
    this.onStartCallbacks = [];
    this.scheduledCallbacks = [];
    this.tempScheduledCallbacks = [];
    this._stopped = true;
    this._running = false;
    this.stoppedTime = null;
    this.diffTime = null;
    if (!k.getInstance().has("game")) throw new Error("You need create Game instance before Stage instance.");
    this.game = k.getInstance().get("game");
    let e = this;
    return this.game.displayErrors && (e = this.game.validatorFactory.createValidator(this, "Stage")), e.id = Symbol(), e.eventEmitter = new H(), e.collisionSystem = new lt(), e.canvas = e.game.canvas, e.context = e.game.context, t && e.addBackground(t), e.addListeners(), e.game.addStage(e), e.scheduledCallbackExecutor = new Z(e), e.stoppedTime = Date.now(), e.init(), e.camera = new pt(e), e;
  }
  init() {
  }
  onStart(t) {
    this.onStartCallbacks.push(t);
  }
  onReady(t) {
    this.onReadyCallbacks.push(t);
  }
  get running() {
    return this._running;
  }
  get stopped() {
    return this._stopped;
  }
  isReady() {
    return this.addedSprites == this.loadedSprites && this.pendingBackgrounds === 0;
  }
  get width() {
    return this.canvas.width;
  }
  get height() {
    return this.canvas.height;
  }
  set backgroundColor(t) {
    this.drawBackground((e, i) => {
      e.fillStyle = t, e.fillRect(0, 0, i.width, i.height);
    });
  }
  drawBackground(t) {
    let e = document.createElement("canvas"), i = e.getContext("2d");
    return e.width = this.width, e.height = this.height, this.pendingBackgrounds++, t(i, this), this.backgrounds.push(e), this.pendingBackgrounds--, this;
  }
  addBackground(t) {
    let e = new Image();
    e.src = t, this.pendingBackgrounds++;
    let i = () => {
      let s = document.createElement("canvas"), n = s.getContext("2d");
      s.width = this.width, s.height = this.height, n.drawImage(e, 0, 0, this.width, this.height), this.backgrounds.push(s), this.pendingBackgrounds--, this.tryDoOnReady(), this.tryDoRun(), e.removeEventListener("load", i);
    };
    return e.addEventListener("load", i), e.addEventListener("error", () => {
      this.game.throwError(y.BACKGROUND_NOT_LOADED, { backgroundPath: t });
    }), this;
  }
  switchBackground(t) {
    this.backgroundIndex = t;
    let e = this.backgrounds[t];
    e && (this.background = e);
  }
  nextBackground() {
    let t = this.backgroundIndex + 1;
    t > this.backgrounds.length - 1 && (t = 0), t !== this.backgroundIndex && this.switchBackground(t);
  }
  addSound(t, e) {
    this.soundNames.includes(e) && this.game.throwError(y.SOUND_NAME_ALREADY_EXISTS, { soundName: e });
    let i = new Audio();
    i.src = t, this.sounds.push(i), this.soundNames.push(e), this.pendingSounds++, i.load();
    let s = () => {
      this.pendingSounds--, this.tryDoOnReady(), i.removeEventListener("loadedmetadata", s);
    };
    return i.addEventListener("loadedmetadata", s), this;
  }
  removeSound(t) {
    let e = this.soundNames.indexOf(t);
    return e < 0 && this.game.throwError(y.SOUND_NAME_NOT_FOUND, { soundName: t }), this.sounds.splice(e, 1), this;
  }
  playSound(t, e = {}) {
    let i = this.getSound(t);
    this.doPlaySound(i, e);
  }
  startSound(t, e = {}) {
    let i = this.cloneSound(t);
    return this.doPlaySound(i, e), i;
  }
  pauseSound(t) {
    this.getSound(t).pause();
  }
  getSound(t) {
    this.isReady() || this.game.throwError(y.SOUND_USE_NOT_READY);
    let e = this.soundNames.indexOf(t);
    e < 0 && this.game.throwError(y.SOUND_NAME_NOT_FOUND, { soundName: t });
    let i = this.sounds[e];
    return i instanceof Audio || this.game.throwError(y.SOUND_INDEX_NOT_FOUND, { soundIndex: e }), i;
  }
  cloneSound(t) {
    let e = this.getSound(t);
    return new Audio(e.src);
  }
  doPlaySound(t, e = {}) {
    e.volume !== void 0 && (t.volume = e.volume), e.currentTime !== void 0 && (t.currentTime = e.currentTime), e.loop !== void 0 && (t.loop = e.loop);
    let i = t.play();
    i !== void 0 && i.catch((s) => {
      s.name === "NotAllowedError" ? this.game.throwError(y.SOUND_NOT_ALLOWED_ERROR, {}, false) : console.error("Audio playback error:", s);
    });
  }
  addSprite(t) {
    let e;
    return this.sprites.has(t.layer) ? e = this.sprites.get(t.layer) : (e = [], this.sprites.set(t.layer, e)), e.push(t), this.addedSprites++, this;
  }
  removeSprite(t, e) {
    this.sprites.has(e) || this.game.throwErrorRaw('The layer "' + e + '" not defined in the stage.');
    let i = this.sprites.get(e);
    return i.splice(i.indexOf(t), 1), i.length || this.sprites.delete(e), (t.deleted || t.isReady()) && this.loadedSprites--, this.addedSprites--, this;
  }
  getSprites() {
    return Array.from(this.sprites.values()).reduce((t, e) => t.concat(e), []);
  }
  changeSpriteLayer(t, e, i) {
    this.sprites.has(e) || this.game.throwErrorRaw('The layer "' + e + '" not defined in the stage.');
    let s = this.sprites.get(e);
    s.splice(s.indexOf(t), 1), s.length || this.sprites.delete(e);
    let n = [];
    this.sprites.has(i) ? n = this.sprites.get(i) : this.sprites.set(i, n), n.push(t);
  }
  drawSprite(t) {
    let e = t.getCostume(), i = e.image, s = t.imageCenterX - t.sourceWidth / 2, n = t.imageCenterY - t.sourceHeight / 2, r = t.sourceWidth, o = t.sourceHeight, a = t.globalDirection, l = t.rotateStyle, h = (t.sourceWidth - e.width * t.size / 100) / 2, d = (t.sourceHeight - e.height * t.size / 100) / 2, c = l === "normal" && a !== 0 || l === "leftRight" && a > 180 || t.opacity !== null || t.filter !== null && t.filter != "";
    c && this.context.save(), t.opacity !== null && (this.context.globalAlpha = t.opacity), t.filter && (this.context.filter = t.filter), l === "normal" && a !== 0 && (this.context.translate(s + r / 2, n + o / 2), this.context.rotate(t.globalAngleRadians), this.context.translate(-s - r / 2, -n - o / 2)), l === "leftRight" && a > 180 ? (this.context.scale(-1, 1), this.context.drawImage(i, 0, 0, e.width, e.height, -s - r + h, n + d, e.width * t.size / 100, e.height * t.size / 100)) : this.context.drawImage(i, 0, 0, e.width, e.height, s + h, n + d, e.width * t.size / 100, e.height * t.size / 100), c && this.context.restore();
  }
  stampImage(t, e, i, s = 0) {
    if (this.background instanceof HTMLCanvasElement) {
      let n = document.createElement("canvas"), r = n.getContext("2d");
      n.width = this.width, n.height = this.height, r.drawImage(this.background, 0, 0, this.width, this.height);
      let o = t instanceof HTMLImageElement ? t.naturalWidth : t.width, a = t instanceof HTMLImageElement ? t.naturalHeight : t.height, l = e - o / 2, h = i - a / 2;
      if (s !== 0) {
        let d = s * Math.PI / 180;
        r.translate(l + o / 2, h + a / 2), r.rotate(d), r.translate(-l - o / 2, -h - a / 2);
      }
      r.drawImage(t, l, h, o, a), this.background = n, this.backgrounds[this.backgroundIndex] = this.background;
    }
  }
  pen(t, e = 0) {
    let i;
    this.drawings.has(e) ? i = this.drawings.get(e) : (i = [], this.drawings.set(e, i)), i.push(t);
  }
  timeout(t, e) {
    this.repeat(t, 1, null, e, void 0);
  }
  repeat(t, e, i = null, s = null, n) {
    let r = new B(i, e, 0);
    return s && (s = Date.now() + s), this.tempScheduledCallbacks.push(new X(t, r, s, n)), r;
  }
  forever(t, e = null, i = null, s) {
    let n = new B(e);
    return i && (i = Date.now() + i), this.tempScheduledCallbacks.push(new X(t, n, i, s)), n;
  }
  render() {
    this.update(), this.collisionSystem.update(), this.context.clearRect(this.camera.startCornerX - this.camera.width / this.camera.zoom / 2, this.camera.startCornerY - this.camera.height / this.camera.zoom / 2, this.width + this.camera.width / this.camera.zoom, this.height + this.camera.height / this.camera.zoom), this.background && this.context.drawImage(this.background, 0, 0, this.width, this.height);
    let t = Array.from(this.sprites.keys()).concat(Array.from(this.drawings.keys()));
    t = t.filter((s, n) => t.indexOf(s) === n), t = t.sort((s, n) => s - n);
    for (let s of t) {
      if (this.drawings.has(s)) {
        let n = this.drawings.get(s);
        for (let r of n) r(this.context, this);
      }
      if (this.sprites.has(s)) {
        let n = this.sprites.get(s);
        for (let r of n) {
          if (r.hidden) continue;
          let o = Math.hypot(r.imageCenterX - this.camera.x, r.imageCenterY - this.camera.y), a = Math.hypot(r.sourceWidth, r.sourceHeight) / 2 * this.camera.zoom;
          if (o > this.camera.renderRadius + a) continue;
          if (this.game.debugMode !== "none") {
            let h = () => {
              let d = r.imageCenterX - this.context.measureText(r.name).width / 2, c = r.imageCenterY + r.height + 20;
              this.context.fillStyle = this.game.debugColor, this.context.font = "16px Arial", this.context.fillText(r.name, d, c), c += 20, this.context.font = "14px Arial", this.context.fillText("x: " + r.x, d, c), c += 20, this.context.fillText("y: " + r.y, d, c), c += 20, this.context.fillText("direction: " + r.direction, d, c), c += 20, this.context.fillText("costume: " + r.getCostumeName(), d, c), c += 20, this.context.fillText("xOffset: " + r.pivotOffsetX, d, c), c += 20, this.context.fillText("yOffset: " + r.pivotOffsetY, d, c), this.context.beginPath(), this.context.moveTo(r.globalX - 2, r.globalY), this.context.lineTo(r.globalX + 2, r.globalY), this.context.moveTo(r.globalX, r.globalY - 2), this.context.lineTo(r.globalX, r.globalY + 2), this.context.stroke();
            };
            this.game.debugMode === "hover" && r.touchMouse() && h(), this.game.debugMode === "forever" && h();
          }
          let l = r.getPhrase();
          l && (this.context.font = "20px Arial", this.context.fillStyle = "black", this.context.fillText(l, 40, this.canvas.height - 40)), r.getCostume() && this.drawSprite(r);
          for (let h of r.drawings) h(this.context, r);
        }
      }
    }
    this.game.debugCollider && (this.context.strokeStyle = this.game.debugColor, this.context.beginPath(), this.collisionSystem.draw(this.context), this.context.stroke()), this.context.translate(-this.camera.changes.x, -this.camera.changes.y);
    let e = this.width / 2 + this.camera.startCornerX, i = this.height / 2 + this.camera.startCornerY;
    this.context.translate(e, i), this.context.scale(this.camera.changes.zoom, this.camera.changes.zoom), this.context.translate(-e, -i), this.camera.changes.reset();
  }
  update() {
    this.tempScheduledCallbacks.length && (this.scheduledCallbacks = this.scheduledCallbacks.concat(this.tempScheduledCallbacks), this.tempScheduledCallbacks = []), this.scheduledCallbacks = this.scheduledCallbacks.filter(this.scheduledCallbackExecutor.execute(Date.now(), this.diffTime)), this.sprites.forEach((t, e) => {
      for (let i of t) {
        if (i.deleted) {
          this.removeSprite(i, e);
          return;
        }
        i.update(this.diffTime);
      }
    }), this.diffTime = 0;
  }
  run() {
    if (this._stopped) {
      this._stopped = false;
      for (let t of this.sprites.values()) for (let e of t) e.run();
      this.pendingRun = true, this.tryDoRun();
    }
  }
  ready() {
    this.tryDoOnReady(), this.tryDoRun();
    for (let t of this.sprites.values()) for (let e of t) e.ready();
  }
  stop() {
    if (!this._stopped) {
      this._running = false, this._stopped = true;
      for (let t of this.sprites.values()) for (let e of t) e.stop();
      this.stoppedTime = Date.now();
    }
  }
  tryDoOnReady() {
    if (this.onReadyPending && this.isReady()) {
      if (this.onReadyPending = false, this.backgrounds.length && this.backgroundIndex === null && this.switchBackground(0), this.onReadyCallbacks.length) {
        for (let t of this.onReadyCallbacks) t();
        this.onReadyCallbacks = [];
      }
      this.game.eventEmitter.emit(D.STAGE_READY_EVENT, { stage: this });
    }
  }
  doOnStart() {
    for (let t of this.onStartCallbacks) setTimeout(() => {
      t();
    });
  }
  tryDoRun() {
    this.pendingRun && !this._running && this.isReady() && (this._running = true, this.pendingRun = false, this.doOnStart(), this.diffTime = Date.now() - this.stoppedTime, setTimeout(() => {
      let t = this.stoppedTime, e = () => {
        this._stopped || t !== this.stoppedTime || (this.render(), requestAnimationFrame(e));
      };
      e();
    }));
  }
  addListeners() {
    this.eventEmitter.on(D.SPRITE_READY_EVENT, D.SPRITE_READY_EVENT, (t) => {
      this.id == t.detail.stageId && (this.loadedSprites++, this.tryDoOnReady(), this.tryDoRun());
    });
  }
};
var ft = class {
  constructor(t, e, i, s) {
    this.trackedKeys = [];
    this.receiveDataConnections = [];
    this.userKeydownCallbacks = /* @__PURE__ */ new Map();
    this.systemLockedChars = {};
    this.userLockedChars = {};
    this.systemMouseLocked = false;
    this.userMouseLocked = false;
    this.game = e, this.connection = i, s && this.defineListeners();
    let n = i.connect(g.RECEIVE_DATA, (o, a) => {
      let l = JSON.parse(o), h = l.char;
      if (!(!a.SendTime || a.Keydown != "true" || a.MemberId != t.id || !this.trackedKeys.includes(h))) {
        if (this.userKeydownCallbacks.has(h)) {
          let d = this.userKeydownCallbacks.get(h)[0], c = (m, f = [h], b = false) => {
            b && (this.userMouseLocked = m);
            for (let v of f) this.userLockedChars[v.toUpperCase()] = m;
          }, _ = 0, p = () => {
            if (this.userLockedChars[h] !== true || _ > 999) {
              let m = l.sync;
              m && e.syncObjects(m, this.game.calcDeltaTime(a.SendTime)), d(t, c);
            } else _++, setTimeout(p, 50);
          };
          p();
        }
        this.systemLockedChars[h] = false;
      }
    });
    this.receiveDataConnections.push(n);
    let r = i.connect(g.RECEIVE_DATA, (o, a) => {
      if (!(!a.SendTime || a.Mousedown != "true" || a.MemberId != t.id)) {
        if (this.userMousedownCallback) {
          let l = this.userMousedownCallback[0], h = JSON.parse(o), d = h.mouseX, c = h.mouseY, _ = h.sync, p = (b, v = [], C = true) => {
            C && (this.userMouseLocked = b);
            for (let S of v) this.userLockedChars[S.toUpperCase()] = b;
          }, m = 0, f = () => {
            if (this.userMouseLocked !== true || m > 999) {
              _ && e.syncObjects(_, this.game.calcDeltaTime(a.SendTime));
              let b = new L(d, c);
              l(b, t, p);
            } else m++, setTimeout(f, 50);
          };
          f();
        }
        this.systemMouseLocked = false;
      }
    });
    this.receiveDataConnections.push(r);
  }
  defineListeners() {
    this.keydownCallback = (t) => {
      let e = P.getChar(t.keyCode);
      if (!this.userKeydownCallbacks.has(e) || this.systemLockedChars[e] === true || this.userLockedChars[e] === true || !this.trackedKeys.includes(e)) return;
      this.systemLockedChars[e] = true;
      let i = this.userKeydownCallbacks.get(e)[1], s = this.userKeydownCallbacks.get(e)[2], n = this.game.packSyncData(i, s);
      this.connection.sendData(JSON.stringify({ char: e, sync: n }), { Keydown: "true" });
    }, this.mousedownCallback = (t) => {
      if (!this.userMousedownCallback || this.systemMouseLocked || this.userMouseLocked) return;
      let e = this.game.correctMouseX(t.clientX), i = this.game.correctMouseY(t.clientY);
      if (!this.game.isInsideGame(e, i)) return;
      this.systemMouseLocked = true;
      let s = this.userMousedownCallback[1], n = this.userMousedownCallback[2], r = this.game.packSyncData(s, n);
      this.connection.sendData(JSON.stringify({ mouseX: e, mouseY: i, sync: r }), { Mousedown: "true" });
    }, document.addEventListener("keydown", this.keydownCallback), document.addEventListener("mousedown", this.mousedownCallback);
  }
  stop() {
    this.keydownCallback && document.removeEventListener("keydown", this.keydownCallback);
    for (let t of this.receiveDataConnections) this.connection.disconnect(g.RECEIVE_DATA, t);
  }
  keyDown(t, e, i, s = []) {
    t = t.toUpperCase(), this.trackedKeys.includes(t) || this.trackedKeys.push(t), this.userKeydownCallbacks.set(t, [e, i, s]);
  }
  removeKeyDownHandler(t) {
    t = t.toUpperCase(), this.userKeydownCallbacks.delete(t);
  }
  mouseDown(t, e, i = []) {
    this.userMousedownCallback = [t, e, i];
  }
  removeMouseDownHandler() {
    this.userMousedownCallback = null;
  }
};
var G = class {
  constructor(t, e) {
    this.parent = t, this.properties = e;
  }
  getMultiplayerName() {
    return this.parent.getMultiplayerName();
  }
  getSyncId() {
    return this.parent.getSyncId();
  }
  increaseSyncId() {
    return this.parent.increaseSyncId();
  }
  getSyncData() {
    let t = {};
    for (let e of this.properties) this.parent[e] && (t[e] = this.parent[e]);
    return t;
  }
  setSyncData(t, e, i) {
    this.parent.setSyncData(t, e, i);
  }
  onSync(t) {
    throw new Error("Not implemented.");
  }
  removeSyncHandler() {
    throw new Error("Not implemented.");
  }
  only(...t) {
    throw new Error("Not implemented.");
  }
};
var gt = class {
  constructor(t, e, i) {
    this.deleted = false;
    this.id = t, this._isMe = e, this.game = i, this.multiplayerName = "player_" + t, this.syncId = 1, this.control = new ft(this, this.game, i.connection, e), this.reservedProps = Object.keys(this), this.reservedProps.push("reservedProps");
  }
  keyDown(t, e, i, s = []) {
    this.control.keyDown(t, e, i, s);
  }
  removeKeyDownHandler(t) {
    this.control.removeKeyDownHandler(t);
  }
  mouseDown(t, e, i = []) {
    this.control.mouseDown(t, e, i);
  }
  removeMouseDownHandler() {
    this.control.removeMouseDownHandler();
  }
  isMe() {
    return this._isMe;
  }
  delete() {
    if (this.deleted) return;
    this.control.stop();
    let t = Object.keys(this);
    for (let e = 0; e < t.length; e++) delete this[t[e]];
    this.deleted = true;
  }
  repeat(t, e, i, s) {
    if (this.deleted) {
      s();
      return;
    }
    if (t < 1) {
      s();
      return;
    }
    let n = e(this);
    if (n === false) {
      s();
      return;
    }
    if (n > 0 && (i = n), t--, t < 1) {
      s();
      return;
    }
    setTimeout(() => {
      requestAnimationFrame(() => this.repeat(t, e, i, s));
    }, i);
  }
  forever(t, e = null) {
    if (this.deleted) return;
    let i = t(this);
    i !== false && (i > 0 && (e = i), e ? setTimeout(() => {
      requestAnimationFrame(() => this.forever(t, e));
    }, e) : requestAnimationFrame(() => this.forever(t)));
  }
  timeout(t, e) {
    setTimeout(() => {
      this.deleted || requestAnimationFrame(() => t(this));
    }, e);
  }
  getMultiplayerName() {
    return this.multiplayerName;
  }
  getSyncId() {
    return this.syncId;
  }
  increaseSyncId() {
    return this.syncId++, this.syncId;
  }
  getSyncData() {
    let t = {};
    for (let e of Object.keys(this)) this.reservedProps.includes(e) || (t[e] = this[e]);
    return t;
  }
  setSyncData(t, e, i) {
    let s = {};
    for (let n in e) e.hasOwnProperty(n) && !this.reservedProps.includes(n) && (s[n] = this[n], this[n] = e[n]);
    this.syncCallback && this.syncCallback(this, t, e, s, i);
  }
  onSync(t) {
    this.syncCallback = t;
  }
  removeSyncHandler() {
    this.syncCallback = null;
  }
  only(...t) {
    return new G(this, t);
  }
};
var bt = class extends Q {
  constructor(t, e = null, i = 1, s = []) {
    super(e, i, s), this.multiplayerName = "sprite_" + t, this.syncId = 1, this.reservedProps = Object.keys(this), this.reservedProps.push("body"), this.reservedProps.push("reservedProps");
  }
  generateUniqueId() {
    return Math.random().toString(36).slice(2) + "-" + Math.random().toString(36).slice(2);
  }
  getCustomerProperties() {
    let t = {};
    for (let e of Object.keys(this)) this.reservedProps.includes(e) || (t[e] = this[e]);
    return t;
  }
  getMultiplayerName() {
    return this.multiplayerName;
  }
  getSyncId() {
    return this.syncId;
  }
  increaseSyncId() {
    return this.syncId++, this.syncId;
  }
  getSyncData() {
    return Object.assign({}, this.getCustomerProperties(), { size: this.size, rotateStyle: this.rotateStyle, costumeIndex: this.costumeIndex, deleted: this._deleted, x: this.x, y: this.y, direction: this.direction, hidden: this.hidden, stopped: this.stopped });
  }
  setSyncData(t, e, i) {
    let s = {};
    for (let n in e) e.hasOwnProperty(n) && !this.reservedProps.includes(n) && (s[n] = this[n], this[n] = e[n]);
    this.syncCallback && this.syncCallback(this, t, e, s, i);
  }
  onSync(t) {
    this.syncCallback = t;
  }
  removeSyncHandler() {
    this.syncCallback = null;
  }
  only(...t) {
    return new G(this, t);
  }
};
var kt = class extends D {
  constructor(e, i, s, n, r = null, o = true, a = "ru", l = 0, h = 0, d = {}) {
    super(s, n, r, o, a);
    this.autoSyncGameTimeout = 0;
    this.players = [];
    this.sharedObjects = [];
    this.autoSyncGameTimeout = h, this.initializeConnection(e, i, l, d);
  }
  send(e, i = {}, s, n = []) {
    if (!this.connection) throw new Error("Connection to the server is not established.");
    let r = { data: e, sync: this.packSyncData(s, n) };
    this.connection.sendData(JSON.stringify(r), i);
  }
  sync(e, i = [], s = {}) {
    if (!i.length) return;
    s.SyncGame = "true";
    let n = this.packSyncData(e, i);
    this.sendData(JSON.stringify(n), s);
  }
  syncGame() {
    let e = this.getSyncObjects(), i = this.packSyncData("game", e);
    this.sendData(JSON.stringify(i), { SyncGame: "true" });
  }
  onConnection(e) {
    this.onConnectionCallback = e;
  }
  removeConnectionHandler(e) {
    this.onConnectionCallback = null;
  }
  onReceive(e) {
    this.onReceiveCallback = e;
  }
  removeReceiveHandler(e) {
    this.onReceiveCallback = null;
  }
  onMemberJoined(e) {
    this.onMemberJoinedCallback = e;
  }
  removeMemberJoinedHandler(e) {
    this.onMemberJoinedCallback = null;
  }
  onMemberLeft(e) {
    this.onMemberLeftCallback = e;
  }
  removeMemberLeftHandler(e) {
    this.onMemberLeftCallback = null;
  }
  onGameStarted(e) {
    this.onGameStartedCallback = e;
  }
  removeGameStartedHandler(e) {
    this.onGameStartedCallback = null;
  }
  onGameStopped(e) {
    this.onGameStoppedCallback = e;
  }
  removeGameStoppedHandler(e) {
    this.onGameStoppedCallback = null;
  }
  onMultiplayerError(e) {
    this.onMultiplayerErrorCallback = e;
  }
  removeMultiplayerErrorHandler(e) {
    this.onMultiplayerErrorCallback = null;
  }
  run() {
    super.run(), this.isHost && this.autoSyncGameTimeout && this.autoSyncGame(this.autoSyncGameTimeout);
  }
  stop() {
    super.stop();
    for (let e of this.players) e.delete();
    this.players = [];
  }
  getPlayers() {
    return this.players;
  }
  addSharedObject(e) {
    this.sharedObjects.push(e);
  }
  removeSharedObject(e) {
    let i = this.sharedObjects.indexOf(e);
    i > -1 && this.sharedObjects.splice(i, 1);
  }
  getSharedObjects() {
    return this.sharedObjects;
  }
  getMultiplayerSprites() {
    return this.getActiveStage() ? this.getActiveStage().getSprites().filter((e) => e instanceof bt) : [];
  }
  getSyncObjects() {
    let e = this.getMultiplayerSprites(), i = this.getPlayers(), s = this.getSharedObjects();
    return [...e, ...i, ...s];
  }
  syncObjects(e, i) {
    let s = this.getSyncObjects();
    for (let [n, r] of Object.entries(e)) for (let o of s) if (r[o.getMultiplayerName()]) {
      let a = r[o.getMultiplayerName()];
      o.setSyncData(n, a, i);
    }
  }
  packSyncData(e, i) {
    let s = {};
    for (let r of i) s[r.getMultiplayerName()] = r.getSyncData(), s[r.getMultiplayerName()].syncId = r.increaseSyncId();
    let n = {};
    return n[e] = s, n;
  }
  sendData(e, i = {}) {
    if (!this.connection) throw new Error("Connection to the server is not established.");
    this.connection.sendData(e, i);
  }
  calcDeltaTime(e) {
    return Date.now() - e - this.connection.deltaTime;
  }
  extrapolate(e, i, s) {
    let n = Math.round(i / s * 0.75);
    for (let r = 0; r < n; r++) e();
  }
  async initializeConnection(e, i, s, n = {}) {
    let r = new g(e);
    try {
      this.connection = await r.connect(i, s, n), this.onConnectionCallback && this.onConnectionCallback(this.connection), this.connection.connect(g.RECEIVE_DATA, (o, a, l) => {
        if (!(!o || !this.running || !a.SendTime)) {
          if (a.SyncGame === "true") {
            let h = JSON.parse(o);
            this.syncObjects(h, this.calcDeltaTime(a.SendTime));
          } else if (a.Keydown !== "true" && a.Mousedown !== "true" && this.onReceiveCallback) {
            o = JSON.parse(o);
            let h = o.userData, d = o.sync;
            this.syncObjects(d, this.calcDeltaTime(a.SendTime)), this.onReceiveCallback(h, a, l);
          }
        }
      }), this.connection.connect(g.MEMBER_JOINED, (o, a) => {
        this.onMemberJoinedCallback && this.onMemberJoinedCallback(o, a);
      }), this.connection.connect(g.MEMBER_LEFT, (o, a) => {
        this.onMemberLeftCallback && this.onMemberLeftCallback(o, a);
      }), this.connection.connect(g.GAME_STARTED, (o) => {
        var _a;
        let a = o.HostId, l = ((_a = o.Members) == null ? void 0 : _a.split(",")) ?? [];
        this.players = l.map((h) => new gt(h, h === this.connection.memberId, this)), this.isHost = a === this.connection.memberId, this.onGameStartedCallback && this.onGameStartedCallback(this.players, o);
      }), this.connection.connect(g.GAME_STOPPED, (o) => {
        this.onGameStoppedCallback && this.onGameStoppedCallback(o);
      }), this.connection.connect(g.ERROR, (o) => {
        this.onMultiplayerError && this.onMultiplayerError(o);
      });
    } catch (o) {
      console.error(o);
    }
  }
  autoSyncGame(e) {
    setInterval(() => {
      this.syncGame();
    }, e);
  }
};
var Tt = class {
  constructor(t) {
    if (this.multiplayerName = "data_" + t, this.syncId = 1, !k.getInstance().has("game")) throw new Error("You need create Game instance before Sprite instance.");
    k.getInstance().get("game").addSharedObject(this);
  }
  generateUniqueId() {
    return Math.random().toString(36).slice(2) + "-" + Math.random().toString(36).slice(2);
  }
  getMultiplayerName() {
    return this.multiplayerName;
  }
  getSyncId() {
    return this.syncId;
  }
  increaseSyncId() {
    return this.syncId++, this.syncId;
  }
  getSyncData() {
    let t = {};
    for (let e of Object.keys(this)) t[e] = this[e];
    return t;
  }
  setSyncData(t, e, i) {
    let s = {};
    for (let n in e) e.hasOwnProperty(n) && (s[n] = this[n], this[n] = e[n]);
    this.syncCallback && this.syncCallback(this, t, e, s, i);
  }
  onSync(t) {
    this.syncCallback = t;
  }
  removeSyncHandler() {
    this.syncCallback = null;
  }
  only(...t) {
    return new G(this, t);
  }
};
export {
  ot as BVH,
  it as BVHBranch,
  pt as Camera,
  _t as CameraChanges,
  Y as CircleCollider,
  q as Collider,
  M as CollisionResult,
  lt as CollisionSystem,
  W as Costume,
  y as ErrorMessages,
  H as EventEmitter,
  D as Game,
  g as JetcodeSocket,
  rt as JetcodeSocketConnection,
  ct as Keyboard,
  P as KeyboardMap,
  dt as Mouse,
  ft as MultiplayerControl,
  kt as MultiplayerGame,
  bt as MultiplayerSprite,
  G as OrphanSharedData,
  gt as Player,
  L as PointCollider,
  w as PolygonCollider,
  k as Registry,
  at as SAT,
  Z as ScheduledCallbackExecutor,
  X as ScheduledCallbackItem,
  B as ScheduledState,
  Tt as SharedData,
  Q as Sprite,
  Ot as Stage,
  ut as Styles,
  mt as ValidatorFactory,
  Rt as aabbAABB,
  Dt as circleCircle,
  xt as polygonCircle,
  Mt as polygonPolygon,
  wt as separatingAxis
};
//# sourceMappingURL=jetcode-scrubjs.js.map
